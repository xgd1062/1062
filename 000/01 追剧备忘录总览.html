<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿½ç•ªè¿›åº¦ç®¡ç† - ä¼˜åŒ–åŒæ­¥ç‰ˆ</title>

    <style>
        :root {
            --primary-color: #f67b8d;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --bg-light: #f4f7f9;
            --card-bg: #ffffff;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --watching-color: #f67b8d;
            --update-color: #ffc107;
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif, 'Microsoft YaHei';
        }

        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-light);
            color: #333;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--watching-color) 0%, #ffc0cb 100%);
            padding: 20px 30px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            flex-wrap: wrap;
        }

        .header h1 {
            margin: 0;
            flex-shrink: 0;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .datetime-info {
            text-align: right;
            line-height: 1.3;
            font-size: 0.8em;
            opacity: 0.9;
            order: -1;
        }

        .datetime-info p {
            margin: 0;
            white-space: nowrap;
        }

        .action-btn,
        button:not(.anime-actions button) {
            padding: 7px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s, transform 0.1s;
            flex-shrink: 0;
            min-width: 70px;
        }

        .action-btn {
            background-color: white;
            color: var(--watching-color);
        }

        #manageSyncBtn,
        #pushBtn {
            background-color: #2196f3;
            color: white;
        }

        #manageSyncBtn:hover,
        #pushBtn:hover {
            background-color: #1e88e5;
        }

        .day-group {
            margin-bottom: 25px;
            padding: 10px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .day-group h3 {
            color: var(--watching-color);
            border-bottom: 2px solid #ffedf0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .anime-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-start;
            justify-content: flex-start;
        }

        .anime-item {
            width: 154px;
            max-width: 100%;
            padding: 10px;
            background-color: var(--bg-light);
            border: 1px solid #dee2e6;
            border-left: 5px solid var(--watching-color);
            border-radius: 6px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .anime-item.deleted {
            opacity: 0.5;
            background-color: #ffeeee;
            border-left: 5px solid var(--danger-color);
            text-decoration: line-through;
        }

        .anime-item.deleted .anime-content h4,
        .anime-item.deleted .anime-content h4 a {
            color: var(--danger-color) !important;
            text-decoration: line-through;
        }

        .anime-content h4 {
            margin: 0 0 5px 0;
            color: #495057;
            font-size: 1em;
            overflow: hidden;
        }

        .anime-content h4 a {
            color: inherit;
            text-decoration: none;
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .anime-content h4 a:hover {
            text-decoration: underline;
        }

        .progress-info {
            font-size: 0.8em;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }

        .progress-info p {
            margin: 0;
            line-height: 1.2;
        }

        .progress-bar {
            height: 6px;
            margin-bottom: 5px;
            background-color: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--watching-color);
            transition: width 0.5s ease-in-out;
        }

        .updated-episode-display {
            color: var(--update-color);
            font-weight: bold;
        }

        .user-episode-display {
            color: #007bff;
            font-weight: bold;
        }

        .action-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dashed #eee;
        }

        .anime-actions {
            display: flex;
            width: 100%;
            gap: 5px;
        }

        .anime-actions button {
            flex-grow: 1;
            flex-basis: 0;
            padding: 5px 0;
            font-size: 0.8em;
            line-height: 1;
            margin: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .plus-one-btn {
            background-color: var(--success-color);
            color: white;
        }

        .edit-btn {
            background-color: var(--secondary-color);
            color: white;
        }

        .delete-btn {
            background-color: var(--danger-color);
            color: white;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 500px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }

        .sync-quick-actions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #eee;
        }

        .sync-quick-actions .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .sync-quick-actions button {
            flex: 1;
            min-width: 0;
            font-weight: bold;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-btn:hover {
            color: #000;
            cursor: pointer;
        }

        #animeForm label,
        #configForm label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }

        #animeForm input,
        #animeForm select,
        #configForm input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        #updateDateDisplay {
            color: #007bff;
            font-weight: bold;
            margin-right: 3px;
        }

        #animeForm button[type="submit"],
        #configForm button[type="submit"] {
            width: 100%;
            background-color: var(--watching-color);
            color: white;
            padding: 12px;
        }

        @media (max-width: 500px) {
            .header {
                padding: 15px;
                flex-direction: column;
            }

            .datetime-info {
                display: none;
            }

            .header-right {
                flex-direction: column;
                width: 100%;
            }

            .action-btn {
                width: 100%;
            }

            .anime-item {
                width: 100%;
            }

            .sync-quick-actions .btn-group {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <header class="header">
        <h1>ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†</h1>
        <div class="header-right">
            <div id="datetime-info" class="datetime-info">
                <p id="current-time" onclick="window.open('https://time.is', '_blank')" style="cursor: pointer;"
                    title="ç‚¹å‡»æŸ¥çœ‹ç²¾ç¡®æ—¶é—´">åŠ è½½ä¸­...</p>
            </div>
            <button id="manageSyncBtn" class="action-btn">åŒæ­¥ç®¡ç†</button>
            <button id="pushBtn" class="action-btn">æ¨é€æœ¬åœ°æ•°æ®</button>
            <button id="showAddModalBtn" class="action-btn">æ–°å¢ç•ªå‰§</button>
        </div>
    </header>

    <main id="overview-container" class="overview-container">
        <p class="loading-text">åŠ è½½ä¸­...</p>
    </main>

    <div id="animeModal" class="modal">
        <div class="modal-content">
            <span class="close-btn anime-close-btn">&times;</span>
            <h2 id="modalTitle">æ–°å¢ç•ªå‰§</h2>
            <form id="animeForm">
                <label for="animeTitle">ç•ªå‰§åç§°:</label>
                <input type="text" id="animeTitle" required>
                <label for="watchLink">è§‚çœ‹é“¾æ¥ (URL):</label>
                <input type="url" id="watchLink" placeholder="ä¾‹å¦‚: https://www.bilibili.com/...">
                <label for="totalEpisodes">æ€»é›†æ•° (0 è¡¨ç¤ºæœªçŸ¥):</label>
                <input type="number" id="totalEpisodes" min="0" value="12" required>
                <label for="manualUpdatedEpisode"><span id="updateDateDisplay">æ—¥æœŸ</span>+æºç«™æœ€æ–°é›†æ•°:</label>
                <input type="number" id="manualUpdatedEpisode" min="1" value="1" required>
                <label for="currentEpisode">æ‚¨æ­£åœ¨çœ‹ç¬¬å‡ é›†:</label>
                <input type="number" id="currentEpisode" min="1" value="1" required>
                <label for="updateDayOfWeek">æ¯å‘¨æ›´æ–°æ—¥:</label>
                <select id="updateDayOfWeek" required>
                    <option value="0">å‘¨æ—¥</option>
                    <option value="1">å‘¨ä¸€</option>
                    <option value="2">å‘¨äºŒ</option>
                    <option value="3">å‘¨ä¸‰</option>
                    <option value="4">å‘¨å››</option>
                    <option value="5">å‘¨äº”</option>
                    <option value="6">å‘¨å…­</option>
                </select>
                <button type="submit" id="saveAnimeBtn">ä¿å­˜</button>
            </form>
        </div>
    </div>

    <div id="githubConfigModal" class="modal">
        <div class="modal-content">
            <span class="close-btn config-close-btn">&times;</span>
            <h2>åŒæ­¥ç®¡ç†</h2>

            <div class="sync-quick-actions">
                <p style="margin:0; font-size: 0.9em; color: #666; font-weight: bold;">ä»äº‘ç«¯åŒæ­¥åˆ°æœ¬åœ°ï¼š</p>
                <div class="btn-group">
                    <button id="downloadOverwriteBtn" class="action-btn"
                        style="background-color: var(--danger-color); color: white;">ä¸‹è½½å¹¶è¦†ç›–</button>
                    <button id="downloadMergeBtn" class="action-btn"
                        style="background-color: var(--info-color); color: white;">ä¸‹è½½å¹¶åˆå¹¶</button>
                </div>
                <p style="font-size: 0.75em; color: #888; margin: 8px 0 0 0;">* è¦†ç›–ï¼šåˆ é™¤æœ¬åœ°ï¼Œå®Œå…¨åŒæ­¥äº‘ç«¯ã€‚<br>* åˆå¹¶ï¼šå°†äº‘ç«¯æ•°æ®ä¸æœ¬åœ°ç°æœ‰è®°å½•æ··åˆã€‚
                </p>
            </div>

            <form id="configForm">
                <label for="githubToken">GitHub ä¸ªäººè®¿é—®ä»¤ç‰Œ (Token):</label>
                <input type="password" id="githubToken" placeholder="éœ€è¦ repo æƒé™çš„ä»¤ç‰Œ" required>
                <label for="githubRepoPath">åŒæ­¥åœ°å€:</label>
                <input type="text" id="githubRepoPath" readonly value="xgd1062/1062/çœ‹ç•ªè®°å½•.md">
                <button type="submit" style="background-color: #2196f3;">ä¿å­˜é…ç½®</button>
            </form>
        </div>
    </div>

    <script>
        // --- [JS é€»è¾‘ä¿æŒä¸å˜] ---
        const LS_KEY = 'animeTrackerWatchingOnlyV2';
        const CONFIG_KEY = 'githubSyncConfig';
        const DAY_NAMES = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];

        let animeData = [];
        let githubConfig = null;

        const DEFAULT_REPO_CONFIG = {
            owner: 'xgd1062',
            repo: '1062',
            path: 'çœ‹ç•ªè®°å½•.md',
            token: null,
            sha: null
        };

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function calculateLastUpdateDateObject(targetDayOfWeek, dateToCheck = new Date()) {
            const now = new Date(dateToCheck);
            now.setHours(0, 0, 0, 0);
            const todayDay = now.getDay();
            const daysToGoBack = (todayDay - targetDayOfWeek + 7) % 7;
            const updateDate = new Date(now);
            updateDate.setDate(now.getDate() - daysToGoBack);
            return updateDate;
        }

        function calculateWeeksElapsed(startDate, currentDate, updateDayOfWeek) {
            const startMidnight = new Date(startDate.getTime());
            startMidnight.setHours(0, 0, 0, 0);
            const currentMidnight = new Date(currentDate.getTime());
            currentMidnight.setHours(0, 0, 0, 0);
            if (currentMidnight.getTime() <= startMidnight.getTime()) return 0;
            let firstUpdateDate = new Date(startMidnight);
            const startDay = startMidnight.getDay();
            const dayDiff = (updateDayOfWeek - startDay + 7) % 7;
            firstUpdateDate.setDate(startMidnight.getDate() + dayDiff);
            if (firstUpdateDate.getTime() === startMidnight.getTime()) {
                firstUpdateDate.setDate(firstUpdateDate.getDate() + 7);
            }
            let count = 0;
            let tempDate = firstUpdateDate;
            while (tempDate.getTime() <= currentMidnight.getTime()) {
                count++;
                tempDate.setDate(tempDate.getDate() + 7);
            }
            return count;
        }

        function calculateUpdatedEpisode(entry, currentDate = new Date()) {
            if (!entry.startCalculationDate || !entry.startCalculationEpisode || entry.deleted) {
                return entry.manualUpdatedEpisode || 1;
            }
            const startDate = new Date(entry.startCalculationDate);
            const weeksElapsed = calculateWeeksElapsed(startDate, currentDate, entry.updateDayOfWeek);
            let newEpisode = entry.startCalculationEpisode + weeksElapsed;
            if (entry.totalEpisodes > 0) newEpisode = Math.min(newEpisode, entry.totalEpisodes);
            return Math.max(1, newEpisode);
        }

        function updateCalculationFields(entry, modifiedDateString, currentUpdatedEpisode) {
            const modifiedDate = new Date(modifiedDateString);
            modifiedDate.setHours(0, 0, 0, 0);
            const targetUpdateDateObj = calculateLastUpdateDateObject(entry.updateDayOfWeek, modifiedDate);
            entry.lastModifiedDate = modifiedDateString;
            entry.startCalculationDate = formatDate(targetUpdateDateObj);
            entry.startCalculationEpisode = currentUpdatedEpisode;
            entry.manualUpdatedEpisode = currentUpdatedEpisode;
        }

        function initData() {
            const storedData = localStorage.getItem(LS_KEY);
            if (storedData) animeData = JSON.parse(storedData);
            const todayDateString = formatDate(new Date());

            animeData = animeData.map(entry => {
                const baseUpdatedEp = entry.manualUpdatedEpisode || 1;
                const updateDay = entry.updateDayOfWeek !== undefined ? parseInt(entry.updateDayOfWeek) : new Date().getDay();
                const baseEntry = {
                    ...entry,
                    deleted: entry.deleted === true,
                    watchLink: entry.watchLink || '',
                    manualUpdatedEpisode: baseUpdatedEp,
                    updateDayOfWeek: updateDay,
                    lastModifiedDate: entry.lastModifiedDate || todayDateString,
                    startCalculationEpisode: entry.startCalculationEpisode || baseUpdatedEp,
                    startCalculationDate: entry.startCalculationDate || formatDate(calculateLastUpdateDateObject(updateDay))
                };
                baseEntry.manualUpdatedEpisode = calculateUpdatedEpisode(baseEntry);
                if (baseEntry.currentEpisode > baseEntry.manualUpdatedEpisode) baseEntry.currentEpisode = baseEntry.manualUpdatedEpisode;
                return baseEntry;
            }).filter(entry => entry.title);

            const storedConfig = localStorage.getItem(CONFIG_KEY);
            githubConfig = storedConfig ? JSON.parse(storedConfig) : DEFAULT_REPO_CONFIG;
        }

        function saveToLocalStorage() { localStorage.setItem(LS_KEY, JSON.stringify(animeData)); }
        function saveGithubConfig() { localStorage.setItem(CONFIG_KEY, JSON.stringify(githubConfig)); }

        function generateMarkdown(data) {
            const liveData = data.filter(entry => !entry.deleted);
            if (liveData.length === 0) return `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º\n\n**æ— è¿½ç•ªè®°å½•**\n\n`;
            const timestamp = new Date().toLocaleString('zh-CN');
            let markdown = `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º (${timestamp})\n\n`;
            const groupedData = groupAnimeByDay(liveData);

            Object.keys(groupedData).sort((a, b) => a - b).forEach(dayKey => {
                const listWithIndex = groupedData[dayKey];
                markdown += `## ${DAY_NAMES[dayKey]}æ›´æ–° (${listWithIndex.length}éƒ¨)\n\n`;
                markdown += '| åç§° | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | è§‚çœ‹é“¾æ¥ |\n| :--- | :--- | :--- | :--- | :--- |\n';
                listWithIndex.forEach(({ entry }) => {
                    const watchUrl = entry.watchLink?.startsWith('http') ? entry.watchLink : '#';
                    const linkText = entry.watchLink ? '[ç‚¹å‡»è§‚çœ‹]' : 'æ— é“¾æ¥';
                    markdown += `| [${entry.title}](${watchUrl}) | ${entry.manualUpdatedEpisode} | ${entry.currentEpisode} | ${entry.totalEpisodes || '??'} | ${linkText} |\n`;
                });
                markdown += '\n';
            });
            return markdown;
        }

        function parseMarkdownToData(markdownContent, remoteBackupDateString) {
            const lines = markdownContent.split('\n');
            const parsedData = [];
            let currentDay = 0;

            lines.forEach(line => {
                const dayMatch = line.match(/^## (.+?)æ›´æ–°/);
                if (dayMatch) currentDay = DAY_NAMES.indexOf(dayMatch[1]);

                const dataMatch = line.match(/^\| \[(.+?)\]\((.+?)\) \| (\d+) \| (\d+) \| (.+?) \|/);
                if (dataMatch) {
                    const title = dataMatch[1].trim();
                    const watchLink = dataMatch[2] === '#' ? '' : dataMatch[2];
                    const updatedEp = parseInt(dataMatch[3]);
                    const currentEp = parseInt(dataMatch[4]);
                    const totalEp = dataMatch[5].trim() === '??' ? 0 : parseInt(dataMatch[5]);

                    const entry = {
                        title, watchLink, totalEpisodes: totalEp, currentEpisode: currentEp,
                        updateDayOfWeek: currentDay, deleted: false
                    };
                    updateCalculationFields(entry, remoteBackupDateString, updatedEp);
                    entry.manualUpdatedEpisode = calculateUpdatedEpisode(entry, new Date());
                    parsedData.push(entry);
                }
            });
            return parsedData;
        }

        function processRemoteAndDelete(remoteData, localData, remoteBackupDateString) {
            const localDeletedTitles = new Set(localData.filter(item => item.deleted).map(item => item.title));
            const merged = [];
            const processedTitles = new Set();

            remoteData.filter(re => !localDeletedTitles.has(re.title)).forEach(remoteEntry => {
                const localEntry = localData.find(le => le.title === remoteEntry.title && !le.deleted);
                if (!localEntry) {
                    merged.push(remoteEntry);
                } else {
                    localEntry.currentEpisode = remoteEntry.currentEpisode;
                    localEntry.totalEpisodes = remoteEntry.totalEpisodes;
                    localEntry.watchLink = remoteEntry.watchLink;
                    localEntry.updateDayOfWeek = remoteEntry.updateDayOfWeek;
                    if (localEntry.manualUpdatedEpisode !== remoteEntry.manualUpdatedEpisode) {
                        updateCalculationFields(localEntry, remoteBackupDateString, remoteEntry.manualUpdatedEpisode);
                    }
                    localEntry.manualUpdatedEpisode = calculateUpdatedEpisode(localEntry, new Date());
                    merged.push(localEntry);
                }
                processedTitles.add(remoteEntry.title);
            });

            localData.forEach(le => { if (!le.deleted && !processedTitles.has(le.title)) merged.push(le); });
            return merged;
        }

        async function fetchFileFromGithub(config) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            const response = await fetch(url, { headers: { 'Authorization': `token ${config.token}`, 'Accept': 'application/vnd.github.v3+json' } });
            if (response.status === 404) return { content: null, sha: null };
            if (!response.ok) throw new Error(`GitHub é”™è¯¯: ${response.status}`);
            const data = await response.json();
            return { content: decodeURIComponent(escape(atob(data.content))), sha: data.sha };
        }

        async function uploadFileToGithub(config, content, sha) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            const payload = {
                message: `Push: ${new Date().toLocaleString()}`,
                content: btoa(unescape(encodeURIComponent(content))),
                sha: sha
            };
            const response = await fetch(url, { method: 'PUT', headers: { 'Authorization': `token ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error("ä¸Šä¼ å¤±è´¥");
        }

        async function handleDownloadOnly(isOverwrite) {
            if (!githubConfig.token) { alert('è¯·å…ˆè¾“å…¥ GitHub ä»¤ç‰Œå¹¶ä¿å­˜ï¼'); return; }
            if (isOverwrite && !confirm('è­¦å‘Šï¼šä¸‹è½½è¦†ç›–å°†åˆ é™¤æ‰€æœ‰æœ¬åœ°è®°å½•ï¼æ˜¯å¦ç»§ç»­ï¼Ÿ')) return;

            const btn = isOverwrite ? document.getElementById('downloadOverwriteBtn') : document.getElementById('downloadMergeBtn');
            const originalText = btn.textContent;
            btn.textContent = 'ä¸‹è½½ä¸­...';
            btn.disabled = true;

            try {
                const { content, sha } = await fetchFileFromGithub(githubConfig);
                if (!content) throw new Error('äº‘ç«¯æ–‡ä»¶ä¸å­˜åœ¨');

                let backupDate = formatDate(new Date());
                const headerMatch = content.split('\n')[0].match(/\((\d{4}\/\d{2}\/\d{2})/);
                if (headerMatch) backupDate = headerMatch[1].replace(/\//g, '-');

                const remoteData = parseMarkdownToData(content, backupDate);

                if (isOverwrite) {
                    animeData = remoteData;
                } else {
                    animeData = processRemoteAndDelete(remoteData, animeData, backupDate);
                }

                saveToLocalStorage();
                renderOverview();
                alert(isOverwrite ? 'è¦†ç›–æˆåŠŸï¼' : 'åˆå¹¶æˆåŠŸï¼');
                githubConfigModal.style.display = 'none';
            } catch (e) {
                alert(`æ“ä½œå¤±è´¥: ${e.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function pushLocalToCloud() {
            if (!githubConfig.token) {
                alert('è¯·å…ˆè®¾ç½® GitHub Tokenï¼');
                document.getElementById('manageSyncBtn').click();
                return;
            }
            const btn = document.getElementById('pushBtn');
            const originalText = btn.textContent;
            btn.textContent = 'æ¨é€ä¸­...';
            btn.disabled = true;

            try {
                const { sha } = await fetchFileFromGithub(githubConfig);
                const todayStr = formatDate(new Date());
                const liveData = animeData.filter(e => !e.deleted);
                liveData.forEach(e => updateCalculationFields(e, todayStr, e.manualUpdatedEpisode));
                await uploadFileToGithub(githubConfig, generateMarkdown(liveData), sha);
                animeData = liveData;
                saveToLocalStorage();
                renderOverview();
                alert('æ¨é€æˆåŠŸï¼æ ‡è®°ä¸ºåˆ é™¤çš„é¡¹ç›®å·²ä»æœ¬åœ°å½»åº•ç§»é™¤ã€‚');
            } catch (e) {
                alert(`æ¨é€å¤±è´¥: ${e.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function groupAnimeByDay(data) {
            const grouped = {};
            data.forEach(entry => {
                const day = entry.updateDayOfWeek;
                if (!grouped[day]) grouped[day] = [];
                grouped[day].push({ entry, originalIndex: animeData.indexOf(entry) });
            });
            return grouped;
        }

        function renderOverview() {
            const container = document.getElementById('overview-container');
            container.innerHTML = '';
            if (animeData.length === 0) { container.innerHTML = '<p style="text-align:center;color:#999;margin-top:50px;">æš‚æ— æ•°æ®ï¼Œè¯·æ–°å¢ç•ªå‰§æˆ–ä»äº‘ç«¯ä¸‹è½½</p>'; return; }

            const today = new Date().getDay();
            const order = [];
            for (let i = 0; i < 7; i++) order.push((today - i + 7) % 7);

            const grouped = groupAnimeByDay(animeData);
            order.forEach((day, idx) => {
                const list = grouped[day];
                if (!list || list.length === 0) return;

                const section = document.createElement('div');
                section.className = 'day-group';
                let label = DAY_NAMES[day];
                if (idx === 0) label += ' (ä»Šå¤©)';
                else if (idx === 1) label += ' (æ˜¨å¤©)';
                else if (idx === 6) label += ' (æ˜å¤©)';

                section.innerHTML = `<h3>${label}æ›´æ–° (${list.length}éƒ¨)</h3>`;
                const row = document.createElement('div');
                row.className = 'anime-row';

                list.forEach(({ entry, originalIndex }) => {
                    entry.manualUpdatedEpisode = calculateUpdatedEpisode(entry);
                    const progress = entry.totalEpisodes > 0 ? (entry.currentEpisode / entry.totalEpisodes * 100) : 0;
                    const item = document.createElement('div');
                    item.className = 'anime-item' + (entry.deleted ? ' deleted' : '');
                    item.innerHTML = `
                        <div class="anime-content"><h4 title="${entry.title}"><a href="${entry.watchLink || '#'}" target="_blank">${entry.title}</a></h4></div>
                        <div class="progress-info">
                            <p>æ€»é›†æ•°: ${entry.totalEpisodes || '??'}</p>
                            <p>æ›´æ–°è‡³: <span class="updated-episode-display">${entry.manualUpdatedEpisode}</span></p>
                            <p>æ‚¨åœ¨çœ‹: <span class="user-episode-display">${entry.currentEpisode}</span></p>
                        </div>
                        <div class="progress-bar"><div class="progress-fill" style="width:${Math.min(100, progress)}%"></div></div>
                        <div class="action-row"><div class="anime-actions">
                            <button class="plus-one-btn" data-index="${originalIndex}">+1</button>
                            <button class="edit-btn" data-index="${originalIndex}">æ”¹</button>
                            <button class="delete-btn" data-index="${originalIndex}">${entry.deleted ? 'æ’¤é”€' : 'åˆ '}</button>
                        </div></div>
                    `;
                    row.appendChild(item);
                });
                section.appendChild(row);
                container.appendChild(section);
            });
            saveToLocalStorage();
        }

        const animeModal = document.getElementById('animeModal');
        const githubConfigModal = document.getElementById('githubConfigModal');
        const configForm = document.getElementById('configForm');
        let currentEditIndex = null;

        document.getElementById('manageSyncBtn').addEventListener('click', () => {
            document.getElementById('githubToken').value = githubConfig.token || '';
            githubConfigModal.style.display = 'flex';
        });

        document.getElementById('downloadOverwriteBtn').addEventListener('click', () => handleDownloadOnly(true));
        document.getElementById('downloadMergeBtn').addEventListener('click', () => handleDownloadOnly(false));

        configForm.addEventListener('submit', (e) => {
            e.preventDefault();
            githubConfig.token = document.getElementById('githubToken').value.trim();
            saveGithubConfig();
            alert('é…ç½®å·²ä¿å­˜ï¼');
            githubConfigModal.style.display = 'none';
        });

        document.getElementById('pushBtn').addEventListener('click', pushLocalToCloud);

        document.getElementById('showAddModalBtn').addEventListener('click', () => {
            currentEditIndex = null;
            document.getElementById('animeForm').reset();
            document.getElementById('modalTitle').textContent = 'æ–°å¢ç•ªå‰§';
            document.getElementById('updateDayOfWeek').value = new Date().getDay();
            updateManualEpisodeLabel(new Date().getDay());
            animeModal.style.display = 'flex';
        });

        function updateManualEpisodeLabel(day) {
            const dateObj = calculateLastUpdateDateObject(day);
            document.getElementById('updateDateDisplay').textContent = `${dateObj.getMonth() + 1}-${dateObj.getDate()}`;
        }

        document.getElementById('updateDayOfWeek').addEventListener('change', (e) => updateManualEpisodeLabel(e.target.value));

        document.getElementById('animeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const entry = {
                title: document.getElementById('animeTitle').value,
                watchLink: document.getElementById('watchLink').value,
                totalEpisodes: parseInt(document.getElementById('totalEpisodes').value),
                currentEpisode: parseInt(document.getElementById('currentEpisode').value),
                updateDayOfWeek: parseInt(document.getElementById('updateDayOfWeek').value),
                deleted: false
            };
            const manualEp = parseInt(document.getElementById('manualUpdatedEpisode').value);
            updateCalculationFields(entry, formatDate(new Date()), manualEp);

            if (currentEditIndex !== null) animeData[currentEditIndex] = entry;
            else animeData.push(entry);

            saveToLocalStorage();
            renderOverview();
            animeModal.style.display = 'none';
        });

        document.getElementById('overview-container').addEventListener('click', (e) => {
            const idx = e.target.dataset.index;
            if (!idx) return;
            const entry = animeData[idx];

            if (e.target.classList.contains('plus-one-btn')) {
                if (entry.currentEpisode < entry.manualUpdatedEpisode) {
                    entry.currentEpisode++;
                    renderOverview();
                } else alert('å·²è¿½å¹³æ›´æ–°ï¼');
            } else if (e.target.classList.contains('delete-btn')) {
                entry.deleted = !entry.deleted;
                renderOverview();
            } else if (e.target.classList.contains('edit-btn')) {
                currentEditIndex = idx;
                document.getElementById('modalTitle').textContent = 'ç¼–è¾‘ç•ªå‰§';
                document.getElementById('animeTitle').value = entry.title;
                document.getElementById('watchLink').value = entry.watchLink;
                document.getElementById('totalEpisodes').value = entry.totalEpisodes;
                document.getElementById('manualUpdatedEpisode').value = entry.manualUpdatedEpisode;
                document.getElementById('currentEpisode').value = entry.currentEpisode;
                document.getElementById('updateDayOfWeek').value = entry.updateDayOfWeek;
                updateManualEpisodeLabel(entry.updateDayOfWeek);
                animeModal.style.display = 'flex';
            }
        });

        document.querySelectorAll('.close-btn').forEach(b => b.onclick = () => {
            animeModal.style.display = 'none';
            githubConfigModal.style.display = 'none';
        });

        function updateTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = `${now.getFullYear()}å¹´${now.getMonth() + 1}æœˆ${now.getDate()}æ—¥ ${DAY_NAMES[now.getDay()]} ${now.toLocaleTimeString()}`;
        }

        window.onload = () => { initData(); renderOverview(); updateTime(); setInterval(updateTime, 1000); };
    </script>
</body>

</html>