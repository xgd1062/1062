<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿½ç•ªè¿›åº¦ç®¡ç† - GitHub åŒæ­¥ (å¸¦å¾…åˆ é™¤çŠ¶æ€)</title>
    
    <style>
        :root {
            --primary-color: #f67b8d; 
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #007bff;
            --bg-light: #f4f7f9;
            --card-bg: #ffffff;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --watching-color: #f67b8d;
            --update-color: #ffc107; 
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif, 'Microsoft YaHei';
        }

        body {
            max-width: 900px; 
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-light);
            color: #333;
        }

        /* å¤´éƒ¨æ ·å¼è°ƒæ•´ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--watching-color) 0%, #ffc0cb 100%);
            padding: 20px 30px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        
        /* å¤´éƒ¨å³ä¾§å®¹å™¨ */
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px; 
        }

        /* æ—¶é—´ä¿¡æ¯åŒºåŸŸ */
        .datetime-info {
            text-align: right;
            line-height: 1.3;
            font-size: 0.9em;
            opacity: 0.9;
        }
        .datetime-info p {
            margin: 0;
            white-space: nowrap;
        }


        /* æŒ‰é’®æ ·å¼ */
        .action-btn, button:not(.anime-actions button) {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
            flex-shrink: 0; 
        }

        .action-btn {
            background-color: white;
            color: var(--watching-color);
        }
        
        #syncBtn { 
             background-color: #2196f3;
             color: white;
        }
        #syncBtn:hover {
            background-color: #1e88e5;
        }


        /* æ¯æ—¥åˆ†ç»„å®¹å™¨ */
        .day-group {
            margin-bottom: 25px;
            padding: 10px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .day-group h3 {
            color: var(--watching-color);
            border-bottom: 2px solid #ffedf0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        /* å¡ç‰‡æ’åˆ—è¡Œ */
        .anime-row {
            display: flex;
            flex-wrap: wrap; 
            gap: 15px; 
            align-items: flex-start;
            justify-content: flex-start;
        }

        /* å•ä¸ªç•ªå‰§å¡ç‰‡ */
        .anime-item {
            width: 154px; 
            padding: 10px;
            background-color: var(--bg-light);
            border: 1px solid #dee2e6;
            border-left: 5px solid var(--watching-color);
            border-radius: 6px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease; /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
        }
        
        /* === NEW: å¾…åˆ é™¤çŠ¶æ€æ ·å¼ === */
        .anime-item.deleted {
            opacity: 0.5;
            background-color: #ffeeee; /* æµ…çº¢è‰²èƒŒæ™¯ */
            border-left: 5px solid var(--danger-color);
            text-decoration: line-through;
        }
        .anime-item.deleted .anime-content h4 {
            color: var(--danger-color);
        }
        .anime-item.deleted .delete-btn {
            background-color: var(--secondary-color) !important; /* å–æ¶ˆåˆ é™¤æŒ‰é’®æ¢è‰² */
        }
        /* ======================== */


        .anime-content h4 {
            margin: 0 0 5px 0;
            color: #495057;
            font-size: 1em;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        
        /* è¿›åº¦ä¿¡æ¯å®¹å™¨ï¼šç´§å‡‘åŒ– */
        .progress-info {
            font-size: 0.8em;
            color: var(--secondary-color);
            margin-bottom: 5px; 
        }
        .progress-info p {
            margin: 0;
            line-height: 1.2;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 6px;
            margin-bottom: 5px; 
        }

        .progress-fill {
             height: 100%;
             background-color: var(--watching-color);
             transition: width 0.5s ease-in-out;
        }
        
        .updated-episode-display { color: var(--update-color); font-weight: bold; }
        .user-episode-display { color: var(--info-color); font-weight: bold; }

        /* åŠ¨ä½œè¡Œï¼šåªåŒ…å«æŒ‰é’® */
        .action-row {
            display: flex;
            flex-direction: row; 
            justify-content: center; 
            align-items: center;
            margin-top: 8px; 
            padding-top: 5px;
            border-top: 1px dashed #eee;
        }

        /* æŒ‰é’®å®¹å™¨ï¼šå¹³å‡åˆ†é…ç©ºé—´ */
        .anime-actions {
            display: flex;
            width: 100%; 
            gap: 5px; 
        }
        .anime-actions button {
            flex-grow: 1; 
            flex-basis: 0;
            padding: 5px 0; 
            font-size: 0.8em; 
            line-height: 1;
            margin: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .plus-one-btn { background-color: var(--success-color); color: white; }
        .edit-btn { background-color: var(--secondary-color); color: white; }
        .delete-btn { background-color: var(--danger-color); color: white; }


        /* å¼¹çª—éƒ¨åˆ† (ä¿æŒä¸å˜) */
        .modal { display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
        .modal-content { background-color: var(--card-bg); padding: 30px; border-radius: 10px; box-shadow: var(--shadow); width: 90%; max-width: 500px; position: relative; }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; top: 10px; right: 20px; }
        .close-btn:hover { color: #000; cursor: pointer; }
        #animeForm label, #configForm label { display: block; margin: 10px 0 5px; font-weight: bold; }
        #animeForm input, #animeForm select, #configForm input { width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #animeForm button[type="submit"], #configForm button[type="submit"] { width: 100%; background-color: var(--watching-color); color: white; padding: 12px; }
    </style>
</head>

<body>
    <header class="header">
        <h1>ğŸ¿ è¿½ç•ªä¸­ - è¿›åº¦ç®¡ç†</h1>
        <div class="header-right">
            <div id="datetime-info" class="datetime-info">
                <p id="current-time">åŠ è½½ä¸­...</p>
            </div>
            <button id="syncBtn" class="action-btn">åŒæ­¥æ•°æ®</button>
            <button id="showAddModalBtn" class="action-btn">æ–°å¢ç•ªå‰§</button>
        </div>
    </header>

    <main id="overview-container" class="overview-container">
        <p class="loading-text">åŠ è½½ä¸­...</p>
    </main>

    <div id="animeModal" class="modal">
        <div class="modal-content">
            <span class="close-btn anime-close-btn">&times;</span>
            <h2 id="modalTitle">æ–°å¢ç•ªå‰§</h2>
            <form id="animeForm">
                <label for="animeTitle">ç•ªå‰§åç§°:</label>
                <input type="text" id="animeTitle" required>

                <label for="totalEpisodes">æ€»é›†æ•° (0 è¡¨ç¤ºæœªçŸ¥):</label>
                <input type="number" id="totalEpisodes" min="0" value="12" required>
                
                <label for="initialUpdatedEpisode">æºç«™å·²æ›´æ–°åˆ°ç¬¬å‡ é›†:</label>
                <input type="number" id="initialUpdatedEpisode" min="1" value="1" required>

                <label for="currentEpisode">æ‚¨æ­£åœ¨çœ‹ç¬¬å‡ é›†:</label>
                <input type="number" id="currentEpisode" min="1" value="1" required>
                
                <label for="updateDayOfWeek">æ¯å‘¨æ›´æ–°æ—¥:</label>
                <select id="updateDayOfWeek" required>
                    <option value="0">å‘¨æ—¥</option>
                    <option value="1">å‘¨ä¸€</option>
                    <option value="2">å‘¨äºŒ</option>
                    <option value="3">å‘¨ä¸‰</option>
                    <option value="4">å‘¨å››</option>
                    <option value="5">å‘¨äº”</option>
                    <option value="6">å‘¨å…­</option>
                </select>

                <button type="submit" id="saveAnimeBtn">ä¿å­˜</button>
            </form>
        </div>
    </div>
    
    <div id="githubConfigModal" class="modal">
        <div class="modal-content">
            <span class="close-btn config-close-btn">&times;</span>
            <h2>GitHub åŒæ­¥é…ç½®</h2>
            <form id="configForm">
                <label for="githubToken">GitHub ä¸ªäººè®¿é—®ä»¤ç‰Œ (Token):</label>
                <input type="password" id="githubToken" placeholder="éœ€è¦ repo æƒé™çš„ä»¤ç‰Œ" required>

                <label for="githubRepoPath">åŒæ­¥åœ°å€ (ç”¨æˆ·å/ä»“åº“å/æ–‡ä»¶å):</label>
                <input type="text" id="githubRepoPath" readonly value="xgd1062/1062/çœ‹ç•ªè®°å½•.md">

                <button type="submit">ä¿å­˜å¹¶åŒæ­¥</button>
                <p style="font-size: 0.8em; margin-top: 15px; color: #666;">
                    * ä»¤ç‰Œä»…å­˜å‚¨åœ¨æ‚¨çš„æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚<br>
                    * è¯·ç¡®ä¿ä»¤ç‰Œæ‹¥æœ‰è®¿é—®è¯¥ä»“åº“çš„æƒé™ã€‚<br>
                    * **æ³¨æ„ï¼š** åœ¨æœ¬åœ° HTML ä¸­ç›´æ¥è°ƒç”¨ GitHub API å¯èƒ½ä¼šé‡åˆ° CORS é™åˆ¶ã€‚
                </p>
            </form>
        </div>
    </div>


    <script>
        // --- 1. æ•°æ®æ¨¡å‹ä¸å­˜å‚¨ ---
        const LS_KEY = 'animeTrackerWatchingOnlyV2';
        const CONFIG_KEY = 'githubSyncConfig';
        const DAY_NAMES = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­']; 
        const MS_PER_DAY = 1000 * 60 * 60 * 24;
        
        let animeData = []; 
        let githubConfig = null;

        const DEFAULT_REPO_CONFIG = {
            owner: 'xgd1062',
            repo: '1062',
            path: 'çœ‹ç•ªè®°å½•.md',
            token: null,
            sha: null
        };

        function initData() {
            const storedData = localStorage.getItem(LS_KEY);
            if (storedData) {
                animeData = JSON.parse(storedData);
            }
            // ç¡®ä¿æ¯ä¸ªè®°å½•éƒ½æœ‰ deleted å­—æ®µ
            animeData = animeData.map(entry => ({
                ...entry,
                deleted: entry.deleted === true // å¦‚æœå­˜åœ¨ä¸”ä¸º true åˆ™ä¿ç•™ trueï¼Œå¦åˆ™ä¸º undefined/false
            }));

            const storedConfig = localStorage.getItem(CONFIG_KEY);
            if (storedConfig) {
                githubConfig = JSON.parse(storedConfig);
            } else {
                githubConfig = DEFAULT_REPO_CONFIG;
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem(LS_KEY, JSON.stringify(animeData));
        }

        function saveGithubConfig() {
            localStorage.setItem(CONFIG_KEY, JSON.stringify(githubConfig));
        }
        
        function getTodayDateString() {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }
        
        /**
         * è‡ªåŠ¨æ›´æ–°é›†æ•°æ ¸å¿ƒé€»è¾‘ (ä¿æŒä¸å˜)
         */
        function calculateCurrentUpdatedEpisode(entry) {
            const dateAdded = new Date(entry.dateAdded + 'T00:00:00Z');
            const updateDay = parseInt(entry.updateDayOfWeek);
            const initialUpdatedEpisode = entry.initialUpdatedEpisode;

            const today = new Date();
            const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));

            const timeDiff = todayUTC.getTime() - dateAdded.getTime();
            const totalDaysPassed = Math.floor(timeDiff / MS_PER_DAY);

            if (totalDaysPassed < 0) return initialUpdatedEpisode;

            const addedDayOfWeek = dateAdded.getUTCDay(); 
            const daysToFirstUpdate = (updateDay - addedDayOfWeek + 7) % 7; 
            
            const daysSinceFirstUpdate = totalDaysPassed - daysToFirstUpdate;

            let weeksPassed = 0;
            if (daysSinceFirstUpdate >= 0) {
                weeksPassed = Math.floor(daysSinceFirstUpdate / 7) + 1;
            }
            
            let calculatedEp = initialUpdatedEpisode + weeksPassed;
            
            if (entry.totalEpisodes > 0) {
                calculatedEp = Math.min(calculatedEp, entry.totalEpisodes);
            }
            
            return Math.max(calculatedEp, initialUpdatedEpisode);
        }
        
        /**
         * æŒ‰æ›´æ–°æ—¥åˆ†ç»„ (ä¿æŒä¸å˜)
         */
        function groupAnimeByDay(data) {
            const groups = {};
            for (let i = 0; i < 7; i++) {
                groups[i] = [];
            }
            data.forEach((entry, originalIndex) => {
                groups[entry.updateDayOfWeek].push({ entry, originalIndex });
            });
            return groups;
        }

        function updateTimeAndWeather() {
            const now = new Date();
            const dayOfWeek = DAY_NAMES[now.getDay()];
            const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const dateString = `${now.getFullYear()}å¹´${now.getMonth() + 1}æœˆ${now.getDate()}æ—¥`;
            
            const timeElement = document.getElementById('current-time');
            if (timeElement) {
                timeElement.innerHTML = `${dateString} ${dayOfWeek} ${timeString}`;
            }
        }
        
        // --- 2. GitHub API åŠåŒæ­¥é€»è¾‘ ---

        /**
         * ç”Ÿæˆ Markdown å†…å®¹ (è¿‡æ»¤æ‰å¾…åˆ é™¤è®°å½•)
         */
        function generateMarkdown(data) {
            // è¿‡æ»¤æ‰æ‰€æœ‰å·²æ ‡è®°åˆ é™¤çš„è®°å½•
            const liveData = data.filter(entry => !entry.deleted);

            if (liveData.length === 0) {
                return `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º\n\n**æ— è¿½ç•ªè®°å½•**\n\n`;
            }

            const now = new Date();
            const timestamp = now.toLocaleString('zh-CN', { 
                year: 'numeric', month: '2-digit', day: '2-digit', 
                hour: '2-digit', minute: '2-digit', second: '2-digit' 
            });

            let markdown = `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º (${timestamp})\n\n`;
            
            const groupedData = groupAnimeByDay(liveData);
            
            for (let day = 0; day < 7; day++) {
                const list = groupedData[day];
                
                if (list.length > 0) {
                    const dayGroupName = DAY_NAMES[day];
                    markdown += `## ${dayGroupName}æ›´æ–° (${list.length}éƒ¨)\n\n`;
                    
                    markdown += '| åç§° | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | æ›´æ–°æ—¥ |\n';
                    markdown += '| :--- | :--- | :--- | :--- | :--- |\n';

                    list.forEach(({ entry }) => {
                        const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);
                        const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';
                        
                        markdown += `| ${entry.title} | ${calculatedUpdatedEp} | ${entry.currentEpisode} | ${totalText} | ${DAY_NAMES[entry.updateDayOfWeek]} |\n`;
                    });
                    markdown += '\n';
                }
            }
            return markdown;
        }
        
        /**
         * è§£æ Markdown å†…å®¹å›æ•°æ®ç»“æ„ (ä¿æŒä¸å˜)
         */
        function parseMarkdownToData(markdownContent) {
            const lines = markdownContent.split('\n');
            const parsedData = [];
            let currentDay = 0; 
            
            const dayNameToIndex = DAY_NAMES.reduce((acc, name, index) => {
                acc[name] = index;
                return acc;
            }, {});

            lines.forEach(line => {
                const dayMatch = line.match(/^## (.+?)æ›´æ–°/);
                if (dayMatch && dayMatch[1] && dayNameToIndex.hasOwnProperty(dayMatch[1])) {
                    currentDay = dayNameToIndex[dayMatch[1]];
                }
                
                const dataMatch = line.match(/^\| (.+?) \| (\d+) \| (\d+) \| (.+?) \| (.+?) \|$/);
                if (dataMatch) {
                    const title = dataMatch[1].trim();
                    const calculatedUpdatedEp = parseInt(dataMatch[2]) || 1;
                    const currentEpisode = parseInt(dataMatch[3]) || 1;
                    const totalEpisodesStr = dataMatch[4].trim();
                    const totalEpisodes = totalEpisodesStr === '??' ? 0 : parseInt(totalEpisodesStr) || 0;

                    const remoteEntry = {
                        title: title,
                        totalEpisodes: totalEpisodes,
                        currentEpisode: currentEpisode, 
                        updateDayOfWeek: currentDay, 
                        dateAdded: getTodayDateString(), 
                        initialUpdatedEpisode: calculatedUpdatedEp,
                        deleted: false // è¿œç¨‹æ•°æ®é»˜è®¤ä¸ºæœªåˆ é™¤çŠ¶æ€
                    };

                    parsedData.push(remoteEntry);
                }
            });

            return parsedData;
        }

        /**
         * **æ–°çš„åˆå¹¶å’Œåˆ é™¤å¤„ç†é€»è¾‘**
         * 1. ç­›é€‰å‡ºæœ¬åœ°æœªåˆ é™¤çš„è®°å½• (`localLiveRecords`)ã€‚
         * 2. è¯†åˆ«æœ¬åœ°å·²æ ‡è®°åˆ é™¤çš„è®°å½• (`localDeletedTitles`)ã€‚
         * 3. è¿‡æ»¤è¿œç¨‹æ•°æ®ï¼Œæ’é™¤é‚£äº›ä¸æœ¬åœ°å¾…åˆ é™¤è®°å½•åŒåçš„æ¡ç›®ã€‚
         * 4. å°†è¿‡æ»¤åçš„è¿œç¨‹æ•°æ®ä¸æœ¬åœ°æœªåˆ é™¤æ•°æ®åˆå¹¶ã€‚
         * @param {Array} remoteData - ä» GitHub ä¸‹è½½çš„æ•°ç»„
         * @param {Array} localData - æœ¬åœ°å®Œæ•´çš„æ•°ç»„ï¼ˆåŒ…å«å·²åˆ é™¤æ ‡è®°ï¼‰
         * @returns {Array} mergedData - åˆå¹¶åçš„â€œæ´»ç€çš„â€æ•°æ®
         */
        function processRemoteAndDelete(remoteData, localData) {
            
            // 1. æœ¬åœ°æœªè¢«æ ‡è®°åˆ é™¤çš„è®°å½•
            const localLiveRecords = localData.filter(item => !item.deleted);
            const localLiveTitles = new Set(localLiveRecords.map(item => item.title));
            
            // 2. æœ¬åœ°å¾…åˆ é™¤çš„è®°å½•
            const localDeletedTitles = new Set(localData
                .filter(item => item.deleted)
                .map(item => item.title));
            
            // 3. è¿‡æ»¤è¿œç¨‹æ•°æ®ï¼šæ’é™¤é‚£äº›åœ¨æœ¬åœ°è¢«æ ‡è®°åˆ é™¤çš„è®°å½•
            const remoteLiveRecords = remoteData.filter(remoteEntry => {
                return !localDeletedTitles.has(remoteEntry.title);
            });
            
            // 4. åˆå¹¶æœ¬åœ°æœªåˆ é™¤è®°å½•å’Œè¿‡æ»¤åçš„è¿œç¨‹è®°å½• (è¿œç¨‹ç‹¬æœ‰çš„æ·»åŠ è¿›æ¥)
            const merged = [...localLiveRecords];

            remoteLiveRecords.forEach(remoteEntry => {
                if (!localLiveTitles.has(remoteEntry.title)) {
                    // è¿œç¨‹è®°å½•æ˜¯æ–°å¢çš„ï¼Œæ·»åŠ åˆ°æœ¬åœ°
                    merged.push(remoteEntry);
                }
            });
            
            return merged; 
        }

        /**
         * ä» GitHub è·å–æ–‡ä»¶å†…å®¹å’Œ SHA (ä¿æŒä¸å˜)
         */
        async function fetchFileFromGithub(config) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Accept': 'application/vnd.github.v3+json' 
                    }
                });

                if (response.status === 404) {
                    return { content: null, sha: null };
                }
                
                if (!response.ok) {
                     const errorJson = await response.json().catch(() => ({ message: response.statusText }));
                     throw new Error(`GitHub Fetch Error: ${response.status} - ${errorJson.message || 'Unknown API Error'}`);
                }

                const contentData = await response.json();
                
                if (contentData.content && contentData.sha) {
                    // Base64 è§£ç ï¼ŒåŒæ—¶å¤„ç† UTF-8 (ä¸­æ–‡) å­—ç¬¦
                    const fileContent = decodeURIComponent(escape(atob(contentData.content))); 
                    return { content: fileContent, sha: contentData.sha };
                }
                
                return { content: null, sha: null }; 
                
            } catch (error) {
                console.error("GitHub Fetch failed:", error);
                throw new Error(`è·å– GitHub æ–‡ä»¶å¤±è´¥: ${error.message || error}`);
            }
        }

        /**
         * ä¸Šä¼ æˆ–æ›´æ–°æ–‡ä»¶åˆ° GitHub (ä¿æŒä¸å˜)
         */
        async function uploadFileToGithub(config, content, sha) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            
            // Base64 ç¼–ç ï¼Œç¡®ä¿ UTF-8 æ”¯æŒ
            const base64Content = btoa(unescape(encodeURIComponent(content))); 
            
            const payload = {
                message: sha ? `Sync: Update watch list via local app at ${new Date().toLocaleString('zh-CN')}` : `Sync: Initial upload of watch list via local app`,
                content: base64Content,
                sha: sha 
            };

            try {
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`GitHub Upload Error: ${response.status} - ${errorJson.message || 'æœªçŸ¥é”™è¯¯'}`);
                }

                const result = await response.json();
                return result; 

            } catch (error) {
                console.error("GitHub Upload failed:", error);
                throw new Error(`ä¸Šä¼  GitHub æ–‡ä»¶å¤±è´¥: ${error.message}`);
            }
        }

        /**
         * ä¸»åŒæ­¥å‡½æ•° (æ›´æ–°äº†åˆå¹¶å’Œåˆ é™¤å¤„ç†)
         */
        async function syncData() {
            if (!githubConfig.token) {
                document.getElementById('syncBtn').disabled = true;
                showConfigModal();
                return;
            }
            
            const syncBtn = document.getElementById('syncBtn');
            const originalText = syncBtn.textContent;
            syncBtn.textContent = 'åŒæ­¥ä¸­...';
            syncBtn.disabled = true;

            try {
                // 1. å°è¯•è·å–äº‘ç«¯æ–‡ä»¶
                const { content: remoteContent, sha } = await fetchFileFromGithub(githubConfig);
                let contentToUpload = '';
                let newSha = sha;
                
                if (remoteContent && remoteContent.trim().length > 0) {
                    // A. æ–‡ä»¶å­˜åœ¨ï¼šåˆå¹¶æ•°æ®
                    console.log('äº‘ç«¯æ–‡ä»¶å­˜åœ¨ï¼Œè¿›è¡Œåˆ é™¤å¤„ç†å’Œåˆå¹¶...');
                    const remoteData = parseMarkdownToData(remoteContent);
                    
                    // æ‰§è¡Œåˆ é™¤æ ‡è®°å¤„ç†å’Œåˆå¹¶
                    const mergedData = processRemoteAndDelete(remoteData, animeData);
                    
                    // å°†åˆå¹¶åçš„æ•°æ®å­˜å›æœ¬åœ°å¹¶é‡æ–°æ¸²æŸ“ (æœ¬åœ°çš„å¾…åˆ é™¤è®°å½•åœ¨æ­¤æ­¥éª¤è¢«æ¸…ç†)
                    animeData = mergedData; 
                    saveToLocalStorage();
                    renderOverview();
                    
                    // ç”Ÿæˆä¸Šä¼ å†…å®¹ (ä»…åŒ…å« mergedData ä¸­çš„è®°å½•ï¼Œå³ live records)
                    contentToUpload = generateMarkdown(mergedData);
                    alert('åŒæ­¥æˆåŠŸï¼šå·²å¤„ç†åˆ é™¤æ ‡è®°ï¼Œä¸‹è½½äº‘ç«¯è®°å½•å¹¶ä¸æœ¬åœ°è®°å½•åˆå¹¶ï¼Œåˆå¹¶åçš„æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°å¹¶é‡æ–°ä¸Šä¼ ï¼');
                } else {
                    // B. æ–‡ä»¶ä¸å­˜åœ¨ï¼šç›´æ¥ä¸Šä¼ æœ¬åœ°æœªåˆ é™¤æ•°æ®
                    console.log('äº‘ç«¯æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œç›´æ¥ä¸Šä¼ æœ¬åœ°æ•°æ®...');
                    
                    // ç¡®ä¿ä¸Šä¼ å‰æœ¬åœ°æ•°æ®å·²æ¸…ç†å·²æ ‡è®°åˆ é™¤çš„è®°å½•
                    const localLiveData = animeData.filter(entry => !entry.deleted);
                    animeData = localLiveData;
                    saveToLocalStorage();
                    renderOverview();

                    contentToUpload = generateMarkdown(localLiveData);
                    newSha = null; 
                    alert('åŒæ­¥æˆåŠŸï¼šé¦–æ¬¡ä¸Šä¼ æœ¬åœ°æ•°æ®åˆ° GitHubï¼');
                }
                
                // 2. ä¸Šä¼ åˆå¹¶/æœ¬åœ°æ•°æ®
                await uploadFileToGithub(githubConfig, contentToUpload, newSha);

            } catch (error) {
                alert(`åŒæ­¥å¤±è´¥ï¼š${error.message}`);
                console.error(error);
            } finally {
                syncBtn.textContent = originalText;
                syncBtn.disabled = false;
            }
        }
        
        // --- 3. æ¸²æŸ“è§†å›¾ (å¢åŠ å¾…åˆ é™¤çŠ¶æ€æ˜¾ç¤º) ---
        const overviewContainer = document.getElementById('overview-container');

        function renderOverview() {
            overviewContainer.innerHTML = '';
            
            if (animeData.length === 0) {
                overviewContainer.innerHTML = '<p style="text-align:center; color:#999;">æš‚æ— è¿½ç•ªè®°å½•ï¼Œç‚¹å‡»â€œæ–°å¢ç•ªå‰§â€å¼€å§‹è¿½ç•ªå§ï¼</p>';
                return;
            }

            const groupedData = groupAnimeByDay(animeData);
            const todayDayIndex = new Date().getDay(); 
            
            for (let i = 0; i < 7; i++) {
                const day = (todayDayIndex + i) % 7; 
                const list = groupedData[day];
                
                if (list.length > 0) {
                    const dayGroupName = DAY_NAMES[day] + (day === todayDayIndex ? ' (ä»Šå¤©)' : '');
                    
                    const dayGroup = document.createElement('div');
                    dayGroup.className = 'day-group';
                    dayGroup.innerHTML = `<h3>${dayGroupName}æ›´æ–° (${list.length}éƒ¨)</h3>`;

                    const animeRow = document.createElement('div');
                    animeRow.className = 'anime-row';

                    list.forEach(({ entry, originalIndex }) => {
                        
                        const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);
                        const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';
                        const progressPercentage = entry.totalEpisodes > 0 
                                                   ? Math.min(100, (entry.currentEpisode / entry.totalEpisodes) * 100).toFixed(0) 
                                                   : 0;

                        const item = document.createElement('div');
                        // === NEW: æ·»åŠ  deleted class ===
                        item.className = 'anime-item' + (entry.deleted ? ' deleted' : '');
                        // ===========================

                        item.innerHTML = `
                            <div class="anime-content">
                                <h4 title="${entry.title}">${entry.title}</h4>
                            </div>

                            <div class="progress-info">
                                <p>æ€»é›†æ•°: ${totalText}</p>
                                <p>æ›´æ–°è‡³: <span class="updated-episode-display">${calculatedUpdatedEp}</span></p>
                                <p>æ‚¨åœ¨çœ‹: <span class="user-episode-display">${entry.currentEpisode}</span></p>
                            </div>

                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progressPercentage > 100 ? 100 : progressPercentage}%;"></div>
                            </div>
                            
                            <div class="action-row">
                                <div class="anime-actions">
                                    <button class="plus-one-btn" data-index="${originalIndex}">+1</button>
                                    <button class="edit-btn" data-index="${originalIndex}">æ”¹</button>
                                    <button class="delete-btn" data-index="${originalIndex}">${entry.deleted ? 'ä¸åˆ ' : 'åˆ '}</button>
                                </div>
                            </div>
                        `;
                        animeRow.appendChild(item);
                    });

                    dayGroup.appendChild(animeRow);
                    overviewContainer.appendChild(dayGroup);
                }
            }
        }


        // --- 4. å¼¹çª—ä¸è¡¨å•å¤„ç† (æ›´æ–°äº† deleted å­—æ®µ) ---

        const animeModal = document.getElementById('animeModal');
        const showAddModalBtn = document.getElementById('showAddModalBtn');
        const animeForm = document.getElementById('animeForm');
        const modalTitle = document.getElementById('modalTitle');

        const animeTitleInput = document.getElementById('animeTitle');
        const totalEpisodesInput = document.getElementById('totalEpisodes');
        const initialUpdatedEpisodeInput = document.getElementById('initialUpdatedEpisode');
        const currentEpisodeInput = document.getElementById('currentEpisode');
        const updateDayOfWeekSelect = document.getElementById('updateDayOfWeek');
        
        let currentEditIndex = null; 

        showAddModalBtn.addEventListener('click', () => {
            modalTitle.textContent = 'æ–°å¢ç•ªå‰§';
            animeForm.reset();
            currentEditIndex = null;
            
            totalEpisodesInput.value = 12;
            initialUpdatedEpisodeInput.value = 1;
            currentEpisodeInput.value = 1;

            const today = new Date();
            updateDayOfWeekSelect.value = today.getDay();

            animeModal.style.display = 'flex';
        });

        animeForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const title = animeTitleInput.value.trim();
            const totalEpisodes = parseInt(totalEpisodesInput.value) || 0;
            const initialUpdatedEpisode = parseInt(initialUpdatedEpisodeInput.value) || 1;
            let currentEpisode = parseInt(currentEpisodeInput.value) || 1;
            const updateDayOfWeek = parseInt(updateDayOfWeekSelect.value);

            const tempEntry = { 
                title, totalEpisodes, 
                currentEpisode: currentEpisode,
                initialUpdatedEpisode, 
                updateDayOfWeek,
                dateAdded: currentEditIndex !== null ? animeData[currentEditIndex].dateAdded : getTodayDateString()
            };
            
            const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(tempEntry);
            
            if (totalEpisodes > 0 && currentEpisode > totalEpisodes) {
                alert(`æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                return;
            }
            if (currentEpisode > calculatedUpdatedEp) {
                 alert(`æ‚¨æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡å½“å‰å·²æ›´æ–°çš„é›†æ•° (${calculatedUpdatedEp})ï¼`);
                 return;
            }
            if (totalEpisodes > 0 && initialUpdatedEpisode > totalEpisodes) {
                 alert(`æºç«™å·²æ›´æ–°é›†æ•° (${initialUpdatedEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                 return;
            }
            if (initialUpdatedEpisode < 1) {
                 alert('æºç«™å·²æ›´æ–°é›†æ•°å¿…é¡»è‡³å°‘ä¸º 1ï¼');
                 return;
            }


            const newEntry = { 
                title, 
                totalEpisodes, 
                initialUpdatedEpisode,
                currentEpisode, 
                updateDayOfWeek,
                dateAdded: getTodayDateString(),
                deleted: false // é»˜è®¤æœªåˆ é™¤
            };

            if (currentEditIndex !== null) {
                // ä¿æŒåŸæ¥çš„ dateAdded å’Œ deleted çŠ¶æ€
                newEntry.dateAdded = animeData[currentEditIndex].dateAdded; 
                newEntry.deleted = animeData[currentEditIndex].deleted;
                animeData[currentEditIndex] = newEntry;
                alert(`ç•ªå‰§ [${title}] å·²æ›´æ–°ï¼`);
            } else {
                animeData.push(newEntry);
                alert(`ç•ªå‰§ [${title}] å·²æˆåŠŸæ·»åŠ ï¼`);
            }

            saveToLocalStorage();
            renderOverview();
            animeModal.style.display = 'none';
            currentEditIndex = null;
        });


        // --- 5. GitHub é…ç½®å¼¹çª—å¤„ç† (ä¿æŒä¸å˜) ---

        const githubConfigModal = document.getElementById('githubConfigModal');
        const configForm = document.getElementById('configForm');
        const githubTokenInput = document.getElementById('githubToken');
        const githubRepoPathInput = document.getElementById('githubRepoPath');

        function showConfigModal() {
            if (githubConfig.token) {
                githubTokenInput.value = githubConfig.token;
            } else {
                 githubTokenInput.value = '';
            }
            githubConfigModal.style.display = 'flex';
        }
        
        configForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const token = githubTokenInput.value.trim();
            if (!token) {
                alert('GitHub ä»¤ç‰Œä¸èƒ½ä¸ºç©ºï¼');
                return;
            }
            
            githubConfig.token = token;
            saveGithubConfig();
            githubConfigModal.style.display = 'none';

            syncData();
        });


        // --- 6. äº‹ä»¶ä»£ç† (åˆ é™¤é€»è¾‘ä¿®æ”¹) ---

        overviewContainer.addEventListener('click', (e) => {
            const target = e.target;
            const index = target.getAttribute('data-index');

            if (target.classList.contains('edit-btn')) {
                // ç¼–è¾‘é€»è¾‘ (ä¿æŒä¸å˜)
                currentEditIndex = parseInt(index);
                const entry = animeData[currentEditIndex];
                
                // å¦‚æœæ˜¯å¾…åˆ é™¤çŠ¶æ€ï¼Œå…ˆæé†’å–æ¶ˆåˆ é™¤
                if (entry.deleted) {
                    alert(`ç•ªå‰§ "${entry.title}" å·²æ ‡è®°ä¸ºå¾…åˆ é™¤çŠ¶æ€ï¼Œè¯·å…ˆç‚¹å‡»â€œå–æ¶ˆåˆ é™¤â€æŒ‰é’®å†è¿›è¡Œç¼–è¾‘ã€‚`);
                    return;
                }
                
                modalTitle.textContent = 'ç¼–è¾‘ç•ªå‰§ä¿¡æ¯';
                
                animeTitleInput.value = entry.title;
                totalEpisodesInput.value = entry.totalEpisodes;
                initialUpdatedEpisodeInput.value = entry.initialUpdatedEpisode;
                currentEpisodeInput.value = entry.currentEpisode;
                updateDayOfWeekSelect.value = entry.updateDayOfWeek;
                
                animeModal.style.display = 'flex';
                
            } else if (target.classList.contains('plus-one-btn')) {
                // +1 é€»è¾‘ (ä¿æŒä¸å˜)
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];
                
                if (entry.deleted) return; // å¾…åˆ é™¤çŠ¶æ€ä¸èƒ½ +1

                const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);

                if (entry.currentEpisode >= calculatedUpdatedEp) {
                    alert(`å½“å‰æ‚¨çœ‹çš„é›†æ•°å·²è¿½å¹³æœ€æ–°æ›´æ–°é›†æ•° (${calculatedUpdatedEp})ï¼Œè¯·ç­‰å¾…ä¸‹å‘¨æ›´æ–°ï¼`);
                    return;
                }
                if (entry.totalEpisodes > 0 && entry.currentEpisode >= entry.totalEpisodes) {
                     alert(`æ­å–œï¼ç•ªå‰§ [${entry.title}] å·²çœ‹å®Œï¼`);
                     return;
                }
                
                animeData[targetIndex].currentEpisode += 1;
                saveToLocalStorage();
                renderOverview();
                
            } else if (target.classList.contains('delete-btn')) {
                // === NEW: è½¯åˆ é™¤é€»è¾‘ ===
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];

                if (entry.deleted) {
                    // å–æ¶ˆåˆ é™¤
                    entry.deleted = false;
                    alert(`ç•ªå‰§ "${entry.title}" å·²æ¢å¤æ­£å¸¸çŠ¶æ€ï¼`);
                } else {
                    // æ ‡è®°ä¸ºå¾…åˆ é™¤
                    entry.deleted = true;
                    alert(`ç•ªå‰§ "${entry.title}" å·²æ ‡è®°ä¸ºå¾…åˆ é™¤çŠ¶æ€ (åŒæ­¥æ—¶å°†æ°¸ä¹…åˆ é™¤)ã€‚`);
                }
                
                saveToLocalStorage();
                renderOverview();
                // ======================
            }
        });


        // --- 7. é€šç”¨æ¨¡æ€æ¡†å…³é—­é€»è¾‘ (ä¿æŒä¸å˜) ---

        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.onclick = (e) => {
                const modal = e.target.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                    currentEditIndex = null;
                }
            };
        });


        // --- 8. åˆå§‹åŒ– (ä¿æŒä¸å˜) ---
        document.addEventListener('DOMContentLoaded', () => {
            initData();
            renderOverview();
            
            updateTimeAndWeather();
            setInterval(updateTimeAndWeather, 1000); 
            
            document.getElementById('syncBtn').addEventListener('click', syncData);
        });
    </script>
</body>

</html>