<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿½ç•ªè¿›åº¦ç®¡ç† - GitHub åŒæ­¥ (æ›´æ–°é€»è¾‘ä¿®æ­£/PC å·¦å¯¹é½/ç§»åŠ¨ç«¯é€‚é…ç‰ˆ)</title>

    <style>
        :root {
            --primary-color: #f67b8d;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #007bff;
            --bg-light: #f4f7f9;
            --card-bg: #ffffff;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --watching-color: #f67b8d;
            --update-color: #ffc107;
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif, 'Microsoft YaHei';
        }

        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-light);
            color: #333;
        }

        /* å¤´éƒ¨æ ·å¼è°ƒæ•´ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--watching-color) 0%, #ffc0cb 100%);
            padding: 20px 30px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            flex-wrap: wrap;
        }

        .header h1 {
            margin: 0;
        }

        /* å¤´éƒ¨å³ä¾§å®¹å™¨ */
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* æ—¶é—´ä¿¡æ¯åŒºåŸŸ */
        .datetime-info {
            text-align: right;
            line-height: 1.3;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .datetime-info p {
            margin: 0;
            white-space: nowrap;
        }


        /* æŒ‰é’®æ ·å¼ */
        .action-btn,
        button:not(.anime-actions button) {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s, transform 0.1s;
            flex-shrink: 0;
            min-width: 80px;
        }

        .action-btn {
            background-color: white;
            color: var(--watching-color);
        }

        #syncBtn {
            background-color: #2196f3;
            color: white;
        }

        #syncBtn:hover {
            background-color: #1e88e5;
        }


        /* æ¯æ—¥åˆ†ç»„å®¹å™¨ */
        .day-group {
            margin-bottom: 25px;
            padding: 10px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .day-group h3 {
            color: var(--watching-color);
            border-bottom: 2px solid #ffedf0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        /* å¡ç‰‡æ’åˆ—è¡Œ - PC å·¦å¯¹é½ */
        .anime-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-start;
            justify-content: flex-start;
        }

        /* å•ä¸ªç•ªå‰§å¡ç‰‡ */
        .anime-item {
            width: 154px;
            max-width: 100%;
            padding: 10px;
            background-color: var(--bg-light);
            border: 1px solid #dee2e6;
            border-left: 5px solid var(--watching-color);
            border-radius: 6px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        /* å¾…åˆ é™¤çŠ¶æ€æ ·å¼ */
        .anime-item.deleted {
            opacity: 0.5;
            background-color: #ffeeee;
            border-left: 5px solid var(--danger-color);
            text-decoration: line-through;
        }

        .anime-item.deleted .anime-content h4 {
            color: var(--danger-color);
        }

        .anime-item.deleted .delete-btn {
            background-color: var(--secondary-color) !important;
        }


        .anime-content h4 {
            margin: 0 0 5px 0;
            color: #495057;
            font-size: 1em;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* è¿›åº¦ä¿¡æ¯å®¹å™¨ï¼šç´§å‡‘åŒ– */
        .progress-info {
            font-size: 0.8em;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }

        .progress-info p {
            margin: 0;
            line-height: 1.2;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 6px;
            margin-bottom: 5px;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--watching-color);
            transition: width 0.5s ease-in-out;
        }

        .updated-episode-display {
            color: var(--update-color);
            font-weight: bold;
        }

        .user-episode-display {
            color: var(--info-color);
            font-weight: bold;
        }

        /* åŠ¨ä½œè¡Œï¼šåªåŒ…å«æŒ‰é’® */
        .action-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dashed #eee;
        }

        /* æŒ‰é’®å®¹å™¨ï¼šå¹³å‡åˆ†é…ç©ºé—´ */
        .anime-actions {
            display: flex;
            width: 100%;
            gap: 5px;
        }

        .anime-actions button {
            flex-grow: 1;
            flex-basis: 0;
            padding: 5px 0;
            font-size: 0.8em;
            line-height: 1;
            margin: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .plus-one-btn {
            background-color: var(--success-color);
            color: white;
        }

        .edit-btn {
            background-color: var(--secondary-color);
            color: white;
        }

        .delete-btn {
            background-color: var(--danger-color);
            color: white;
        }


        /* å¼¹çª—éƒ¨åˆ† */
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 500px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-btn:hover {
            color: #000;
            cursor: pointer;
        }

        #animeForm label,
        #configForm label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }

        #animeForm input,
        #animeForm select,
        #configForm input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        #animeForm button[type="submit"],
        #configForm button[type="submit"] {
            width: 100%;
            background-color: var(--watching-color);
            color: white;
            padding: 12px;
        }


        /* === ç§»åŠ¨ç«¯åª’ä½“æŸ¥è¯¢ï¼šç¡®ä¿ç§»åŠ¨ç«¯ä»èƒ½æ­£ç¡®æ˜¾ç¤º === */
        @media (max-width: 500px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 15px;
                flex-direction: column;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
                text-align: center;
            }

            .datetime-info {
                display: none;
            }

            .header-right {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                width: 100%;
            }

            .action-btn,
            button:not(.anime-actions button) {
                width: 100%;
            }

            /* å¡ç‰‡å¸ƒå±€æ”¹ä¸ºå•åˆ—ï¼Œå¹¶æ‹‰ä¼¸ä»¥å……æ»¡å®½åº¦ */
            .anime-item {
                width: 100%;
                max-width: 100%;
            }

            .anime-row {
                gap: 10px;
                justify-content: stretch;
            }

            .day-group {
                padding: 5px;
            }
        }
    </style>
</head>

<body>
    <header class="header">
        <h1>ğŸ¿ è¿½ç•ªä¸­ - è¿›åº¦ç®¡ç†</h1>
        <div class="header-right">
            <div id="datetime-info" class="datetime-info">
                <p id="current-time">åŠ è½½ä¸­...</p>
            </div>
            <button id="syncBtn" class="action-btn">åŒæ­¥æ•°æ®</button>
            <button id="showAddModalBtn" class="action-btn">æ–°å¢ç•ªå‰§</button>
        </div>
    </header>

    <main id="overview-container" class="overview-container">
        <p class="loading-text">åŠ è½½ä¸­...</p>
    </main>

    <div id="animeModal" class="modal">
        <div class="modal-content">
            <span class="close-btn anime-close-btn">&times;</span>
            <h2 id="modalTitle">æ–°å¢ç•ªå‰§</h2>
            <form id="animeForm">
                <label for="animeTitle">ç•ªå‰§åç§°:</label>
                <input type="text" id="animeTitle" required>

                <label for="totalEpisodes">æ€»é›†æ•° (0 è¡¨ç¤ºæœªçŸ¥):</label>
                <input type="number" id="totalEpisodes" min="0" value="12" required>

                <label for="initialUpdatedEpisode">æºç«™å·²æ›´æ–°åˆ°ç¬¬å‡ é›†:</label>
                <input type="number" id="initialUpdatedEpisode" min="1" value="1" required>

                <label for="currentEpisode">æ‚¨æ­£åœ¨çœ‹ç¬¬å‡ é›†:</label>
                <input type="number" id="currentEpisode" min="1" value="1" required>

                <label for="updateDayOfWeek">æ¯å‘¨æ›´æ–°æ—¥:</label>
                <select id="updateDayOfWeek" required>
                    <option value="0">å‘¨æ—¥</option>
                    <option value="1">å‘¨ä¸€</option>
                    <option value="2">å‘¨äºŒ</option>
                    <option value="3">å‘¨ä¸‰</option>
                    <option value="4">å‘¨å››</option>
                    <option value="5">å‘¨äº”</option>
                    <option value="6">å‘¨å…­</option>
                </select>

                <button type="submit" id="saveAnimeBtn">ä¿å­˜</button>
            </form>
        </div>
    </div>

    <div id="githubConfigModal" class="modal">
        <div class="modal-content">
            <span class="close-btn config-close-btn">&times;</span>
            <h2>GitHub åŒæ­¥é…ç½®</h2>
            <form id="configForm">
                <label for="githubToken">GitHub ä¸ªäººè®¿é—®ä»¤ç‰Œ (Token):</label>
                <input type="password" id="githubToken" placeholder="éœ€è¦ repo æƒé™çš„ä»¤ç‰Œ" required>

                <label for="githubRepoPath">åŒæ­¥åœ°å€ (ç”¨æˆ·å/ä»“åº“å/æ–‡ä»¶å):</label>
                <input type="text" id="githubRepoPath" readonly value="xgd1062/1062/çœ‹ç•ªè®°å½•.md">

                <button type="submit">ä¿å­˜å¹¶åŒæ­¥</button>
                <p style="font-size: 0.8em; margin-top: 15px; color: #666;">
                    * ä»¤ç‰Œä»…å­˜å‚¨åœ¨æ‚¨çš„æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚<br>
                    * è¯·ç¡®ä¿ä»¤ç‰Œæ‹¥æœ‰è®¿é—®è¯¥ä»“åº“çš„æƒé™ã€‚<br>
                    * **æ³¨æ„ï¼š** åœ¨æœ¬åœ° HTML ä¸­ç›´æ¥è°ƒç”¨ GitHub API å¯èƒ½ä¼šé‡åˆ° CORS é™åˆ¶ã€‚
                </p>
            </form>
        </div>
    </div>


    <script>
        // --- 1. æ•°æ®æ¨¡å‹ä¸å­˜å‚¨ ---
        const LS_KEY = 'animeTrackerWatchingOnlyV2';
        const CONFIG_KEY = 'githubSyncConfig';
        const DAY_NAMES = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        const MS_PER_DAY = 1000 * 60 * 60 * 24;

        let animeData = [];
        let githubConfig = null;

        const DEFAULT_REPO_CONFIG = {
            owner: 'xgd1062',
            repo: '1062',
            path: 'çœ‹ç•ªè®°å½•.md',
            token: null,
            sha: null
        };

        function initData() {
            const storedData = localStorage.getItem(LS_KEY);
            if (storedData) {
                animeData = JSON.parse(storedData);
            }
            animeData = animeData.map(entry => ({
                ...entry,
                deleted: entry.deleted === true
            }));

            const storedConfig = localStorage.getItem(CONFIG_KEY);
            if (storedConfig) {
                githubConfig = JSON.parse(storedConfig);
            } else {
                githubConfig = DEFAULT_REPO_CONFIG;
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem(LS_KEY, JSON.stringify(animeData));
        }

        function saveGithubConfig() {
            localStorage.setItem(CONFIG_KEY, JSON.stringify(githubConfig));
        }

        function getTodayDateString() {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        /**
         * è‡ªåŠ¨æ›´æ–°é›†æ•°æ ¸å¿ƒé€»è¾‘ (å·²æ ¹æ®ç”¨æˆ·éœ€æ±‚ä¿®æ­£)
         */
        function calculateCurrentUpdatedEpisode(entry) {
            const dateAdded = new Date(entry.dateAdded + 'T00:00:00Z');
            const updateDay = parseInt(entry.updateDayOfWeek);
            const initialUpdatedEpisode = entry.initialUpdatedEpisode;

            const today = new Date();
            // ä½¿ç”¨ UTC æ—¥æœŸæ¥ç¡®ä¿æ˜ŸæœŸå‡ å’Œæ—¥æœŸè®¡ç®—çš„å‡†ç¡®æ€§
            const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));

            const timeDiff = todayUTC.getTime() - dateAdded.getTime();
            const totalDaysPassed = Math.floor(timeDiff / MS_PER_DAY);

            // å¦‚æœä»Šå¤©æ—©äºæ·»åŠ æ—¥æœŸï¼Œåˆ™ä¸è®¡ç®—
            if (totalDaysPassed < 0) return initialUpdatedEpisode;

            // 1. è®¡ç®—ä»æ·»åŠ æ—¥æœŸåˆ°ä¸‹ä¸€ä¸ªæ›´æ–°æ—¥çš„é—´éš”å¤©æ•°
            const addedDayOfWeek = dateAdded.getUTCDay();
            let daysToFirstUpdate = (updateDay - addedDayOfWeek + 7) % 7;

            // 2. æ ¸å¿ƒä¿®æ­£é€»è¾‘ï¼š
            // å¦‚æœ daysToFirstUpdate ä¸º 0ï¼Œè¯´æ˜æ·»åŠ å½“å¤©å°±æ˜¯æ›´æ–°æ—¥ã€‚
            // æ ¹æ®ç”¨æˆ·è¦æ±‚ï¼Œæ­¤æ—¶é¦–æ¬¡æ›´æ–°åº”ä»ä¸‹ä¸€å‘¨å¼€å§‹ç®—ï¼Œæ‰€ä»¥å°†é¦–æ¬¡æ›´æ–°æ—¥å»¶è¿Ÿ 7 å¤©ã€‚
            if (daysToFirstUpdate === 0) {
                daysToFirstUpdate = 7;
            }

            // 3. è®¡ç®—ä»é¦–æ¬¡â€œæœ‰æ•ˆâ€æ›´æ–°æ—¥å¼€å§‹ï¼Œè¿‡å»äº†å¤šå°‘å¤©
            const daysSinceFirstEffectiveUpdate = totalDaysPassed - daysToFirstUpdate;

            let weeksPassed = 0;
            if (daysSinceFirstEffectiveUpdate >= 0) {
                // å¦‚æœæ˜¯é¦–æ¬¡æœ‰æ•ˆæ›´æ–°æ—¥ (daysSinceFirstEffectiveUpdate = 0)
                // Math.floor(0/7) + 1 = 1ï¼Œæ­£ç¡®è®¡ç®—äº†æœ¬æ¬¡æ›´æ–°
                weeksPassed = Math.floor(daysSinceFirstEffectiveUpdate / 7) + 1;
            }

            let calculatedEp = initialUpdatedEpisode + weeksPassed;

            // 4. æˆªæ­¢é€»è¾‘
            if (entry.totalEpisodes > 0) {
                calculatedEp = Math.min(calculatedEp, entry.totalEpisodes);
            }

            return Math.max(calculatedEp, initialUpdatedEpisode);
        }

        /**
         * æŒ‰æ›´æ–°æ—¥åˆ†ç»„
         */
        function groupAnimeByDay(data) {
            const groups = {};
            for (let i = 0; i < 7; i++) {
                groups[i] = [];
            }
            data.forEach((entry, originalIndex) => {
                groups[entry.updateDayOfWeek].push({ entry, originalIndex });
            });
            return groups;
        }

        function updateTimeAndWeather() {
            const now = new Date();
            const dayOfWeek = DAY_NAMES[now.getDay()];
            const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const dateString = `${now.getFullYear()}å¹´${now.getMonth() + 1}æœˆ${now.getDate()}æ—¥`;

            const timeElement = document.getElementById('current-time');
            if (timeElement) {
                // ä»…åœ¨ PC ç«¯æ˜¾ç¤ºæ—¶é—´ï¼Œç§»åŠ¨ç«¯ CSS å·²éšè—
                if (window.innerWidth > 500) {
                    timeElement.innerHTML = `${dateString} ${dayOfWeek} ${timeString}`;
                } else {
                    timeElement.innerHTML = '';
                }
            }
        }

        // --- 2. GitHub API åŠåŒæ­¥é€»è¾‘ ---

        /**
         * ç”Ÿæˆ Markdown å†…å®¹ (è¿‡æ»¤æ‰å¾…åˆ é™¤è®°å½•)
         */
        function generateMarkdown(data) {
            const liveData = data.filter(entry => !entry.deleted);

            if (liveData.length === 0) {
                return `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º\n\n**æ— è¿½ç•ªè®°å½•**\n\n`;
            }

            const now = new Date();
            const timestamp = now.toLocaleString('zh-CN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });

            let markdown = `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º (${timestamp})\n\n`;

            const groupedData = groupAnimeByDay(liveData);

            for (let day = 0; day < 7; day++) {
                const list = groupedData[day];

                if (list.length > 0) {
                    const dayGroupName = DAY_NAMES[day];
                    markdown += `## ${dayGroupName}æ›´æ–° (${list.length}éƒ¨)\n\n`;

                    markdown += '| åç§° | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | æ›´æ–°æ—¥ |\n';
                    markdown += '| :--- | :--- | :--- | :--- | :--- | \n';

                    list.forEach(({ entry }) => {
                        const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);
                        const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';

                        markdown += `| ${entry.title} | ${calculatedUpdatedEp} | ${entry.currentEpisode} | ${totalText} | ${DAY_NAMES[entry.updateDayOfWeek]} |\n`;
                    });
                    markdown += '\n';
                }
            }
            return markdown;
        }

        /**
         * è§£æ Markdown å†…å®¹å›æ•°æ®ç»“æ„ 
         */
        function parseMarkdownToData(markdownContent) {
            const lines = markdownContent.split('\n');
            const parsedData = [];
            let currentDay = 0;

            const dayNameToIndex = DAY_NAMES.reduce((acc, name, index) => {
                acc[name] = index;
                return acc;
            }, {});

            lines.forEach(line => {
                const dayMatch = line.match(/^## (.+?)æ›´æ–°/);
                if (dayMatch && dayMatch[1] && dayNameToIndex.hasOwnProperty(dayMatch[1])) {
                    currentDay = dayNameToIndex[dayMatch[1]];
                }

                const dataMatch = line.match(/^\| (.+?) \| (\d+) \| (\d+) \| (.+?) \| (.+?) \|$/);
                if (dataMatch) {
                    const title = dataMatch[1].trim();
                    const calculatedUpdatedEp = parseInt(dataMatch[2]) || 1;
                    const currentEpisode = parseInt(dataMatch[3]) || 1;
                    const totalEpisodesStr = dataMatch[4].trim();
                    const totalEpisodes = totalEpisodesStr === '??' ? 0 : parseInt(totalEpisodesStr) || 0;

                    const remoteEntry = {
                        title: title,
                        totalEpisodes: totalEpisodes,
                        currentEpisode: currentEpisode,
                        updateDayOfWeek: currentDay,
                        dateAdded: getTodayDateString(),
                        initialUpdatedEpisode: calculatedUpdatedEp,
                        deleted: false
                    };

                    parsedData.push(remoteEntry);
                }
            });

            return parsedData;
        }

        /**
         * æ–°çš„åˆå¹¶å’Œåˆ é™¤å¤„ç†é€»è¾‘
         */
        function processRemoteAndDelete(remoteData, localData) {

            // 1. æœ¬åœ°æœªè¢«æ ‡è®°åˆ é™¤çš„è®°å½•
            const localLiveRecords = localData.filter(item => !item.deleted);
            const localLiveTitles = new Set(localLiveRecords.map(item => item.title));

            // 2. æœ¬åœ°å¾…åˆ é™¤çš„è®°å½•
            const localDeletedTitles = new Set(localData
                .filter(item => item.deleted)
                .map(item => item.title));

            // 3. è¿‡æ»¤è¿œç¨‹æ•°æ®ï¼šæ’é™¤é‚£äº›åœ¨æœ¬åœ°è¢«æ ‡è®°åˆ é™¤çš„è®°å½•
            const remoteLiveRecords = remoteData.filter(remoteEntry => {
                return !localDeletedTitles.has(remoteEntry.title);
            });

            // 4. åˆå¹¶æœ¬åœ°æœªåˆ é™¤è®°å½•å’Œè¿‡æ»¤åçš„è¿œç¨‹è®°å½• (è¿œç¨‹ç‹¬æœ‰çš„æ·»åŠ è¿›æ¥)
            const merged = [...localLiveRecords];

            remoteLiveRecords.forEach(remoteEntry => {
                if (!localLiveTitles.has(remoteEntry.title)) {
                    merged.push(remoteEntry);
                }
            });

            return merged;
        }

        /**
         * ä» GitHub è·å–æ–‡ä»¶å†…å®¹å’Œ SHA 
         */
        async function fetchFileFromGithub(config) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.status === 404) {
                    return { content: null, sha: null };
                }

                if (!response.ok) {
                    const errorJson = await response.json().catch(() => ({ message: response.statusText }));
                    throw new Error(`GitHub Fetch Error: ${response.status} - ${errorJson.message || 'Unknown API Error'}`);
                }

                const contentData = await response.json();

                if (contentData.content && contentData.sha) {
                    // Base64 è§£ç ï¼ŒåŒæ—¶å¤„ç† UTF-8 (ä¸­æ–‡) å­—ç¬¦
                    const fileContent = decodeURIComponent(escape(atob(contentData.content)));
                    return { content: fileContent, sha: contentData.sha };
                }

                return { content: null, sha: null };

            } catch (error) {
                console.error("GitHub Fetch failed:", error);
                throw new Error(`è·å– GitHub æ–‡ä»¶å¤±è´¥: ${error.message || error}`);
            }
        }

        /**
         * ä¸Šä¼ æˆ–æ›´æ–°æ–‡ä»¶åˆ° GitHub 
         */
        async function uploadFileToGithub(config, content, sha) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;

            // Base64 ç¼–ç ï¼Œç¡®ä¿ UTF-8 æ”¯æŒ
            const base64Content = btoa(unescape(encodeURIComponent(content)));

            const payload = {
                message: sha ? `Sync: Update watch list via local app at ${new Date().toLocaleString('zh-CN')}` : `Sync: Initial upload of watch list via local app`,
                content: base64Content,
                sha: sha
            };

            try {
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`GitHub Upload Error: ${response.status} - ${errorJson.message || 'æœªçŸ¥é”™è¯¯'}`);
                }

                const result = await response.json();
                return result;

            } catch (error) {
                console.error("GitHub Upload failed:", error);
                throw new Error(`ä¸Šä¼  GitHub æ–‡ä»¶å¤±è´¥: ${error.message}`);
            }
        }

        /**
         * ä¸»åŒæ­¥å‡½æ•°
         */
        async function syncData() {
            if (!githubConfig.token) {
                document.getElementById('syncBtn').disabled = true;
                showConfigModal();
                return;
            }

            const syncBtn = document.getElementById('syncBtn');
            const originalText = syncBtn.textContent;
            syncBtn.textContent = 'åŒæ­¥ä¸­...';
            syncBtn.disabled = true;

            try {
                // 1. å°è¯•è·å–äº‘ç«¯æ–‡ä»¶
                const { content: remoteContent, sha } = await fetchFileFromGithub(githubConfig);
                let contentToUpload = '';
                let newSha = sha;

                if (remoteContent && remoteContent.trim().length > 0) {
                    // A. æ–‡ä»¶å­˜åœ¨ï¼šåˆå¹¶æ•°æ®
                    console.log('äº‘ç«¯æ–‡ä»¶å­˜åœ¨ï¼Œè¿›è¡Œåˆ é™¤å¤„ç†å’Œåˆå¹¶...');
                    const remoteData = parseMarkdownToData(remoteContent);

                    // æ‰§è¡Œåˆ é™¤æ ‡è®°å¤„ç†å’Œåˆå¹¶
                    const mergedData = processRemoteAndDelete(remoteData, animeData);

                    // å°†åˆå¹¶åçš„æ•°æ®å­˜å›æœ¬åœ°å¹¶é‡æ–°æ¸²æŸ“ (æœ¬åœ°çš„å¾…åˆ é™¤è®°å½•åœ¨æ­¤æ­¥éª¤è¢«æ¸…ç†)
                    animeData = mergedData;
                    saveToLocalStorage();
                    renderOverview();

                    // ç”Ÿæˆä¸Šä¼ å†…å®¹ (ä»…åŒ…å« live records)
                    contentToUpload = generateMarkdown(mergedData);
                    alert('åŒæ­¥æˆåŠŸï¼šå·²å¤„ç†åˆ é™¤æ ‡è®°ï¼Œä¸‹è½½äº‘ç«¯è®°å½•å¹¶ä¸æœ¬åœ°è®°å½•åˆå¹¶ï¼Œåˆå¹¶åçš„æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°å¹¶é‡æ–°ä¸Šä¼ ï¼');
                } else {
                    // B. æ–‡ä»¶ä¸å­˜åœ¨ï¼šç›´æ¥ä¸Šä¼ æœ¬åœ°æœªåˆ é™¤æ•°æ®
                    console.log('äº‘ç«¯æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œç›´æ¥ä¸Šä¼ æœ¬åœ°æ•°æ®...');

                    // ç¡®ä¿ä¸Šä¼ å‰æœ¬åœ°æ•°æ®å·²æ¸…ç†å·²æ ‡è®°åˆ é™¤çš„è®°å½•
                    const localLiveData = animeData.filter(entry => !entry.deleted);
                    animeData = localLiveData;
                    saveToLocalStorage();
                    renderOverview();

                    contentToUpload = generateMarkdown(localLiveData);
                    newSha = null;
                    alert('åŒæ­¥æˆåŠŸï¼šé¦–æ¬¡ä¸Šä¼ æœ¬åœ°æ•°æ®åˆ° GitHubï¼');
                }

                // 2. ä¸Šä¼ åˆå¹¶/æœ¬åœ°æ•°æ®
                await uploadFileToGithub(githubConfig, contentToUpload, newSha);

            } catch (error) {
                alert(`åŒæ­¥å¤±è´¥ï¼š${error.message}`);
                console.error(error);
            } finally {
                syncBtn.textContent = originalText;
                syncBtn.disabled = false;
            }
        }

        // --- 3. æ¸²æŸ“è§†å›¾ ---
        const overviewContainer = document.getElementById('overview-container');

        function renderOverview() {
            overviewContainer.innerHTML = '';

            if (animeData.length === 0) {
                overviewContainer.innerHTML = '<p style="text-align:center; color:#999;">æš‚æ— è¿½ç•ªè®°å½•ï¼Œç‚¹å‡»â€œæ–°å¢ç•ªå‰§â€å¼€å§‹è¿½ç•ªå§ï¼</p>';
                return;
            }

            const groupedData = groupAnimeByDay(animeData);
            const todayDayIndex = new Date().getDay();

            for (let i = 0; i < 7; i++) {
                const day = (todayDayIndex + i) % 7;
                const list = groupedData[day];

                if (list.length > 0) {
                    const dayGroupName = DAY_NAMES[day] + (day === todayDayIndex ? ' (ä»Šå¤©)' : '');

                    const dayGroup = document.createElement('div');
                    dayGroup.className = 'day-group';
                    dayGroup.innerHTML = `<h3>${dayGroupName}æ›´æ–° (${list.length}éƒ¨)</h3>`;

                    const animeRow = document.createElement('div');
                    animeRow.className = 'anime-row';

                    list.forEach(({ entry, originalIndex }) => {

                        const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);
                        const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';
                        const progressPercentage = entry.totalEpisodes > 0
                            ? Math.min(100, (entry.currentEpisode / entry.totalEpisodes) * 100).toFixed(0)
                            : 0;

                        const item = document.createElement('div');
                        item.className = 'anime-item' + (entry.deleted ? ' deleted' : '');

                        item.innerHTML = `
                            <div class="anime-content">
                                <h4 title="${entry.title}">${entry.title}</h4>
                            </div>

                            <div class="progress-info">
                                <p>æ€»é›†æ•°: ${totalText}</p>
                                <p>æ›´æ–°è‡³: <span class="updated-episode-display">${calculatedUpdatedEp}</span></p>
                                <p>æ‚¨åœ¨çœ‹: <span class="user-episode-display">${entry.currentEpisode}</span></p>
                            </div>

                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progressPercentage > 100 ? 100 : progressPercentage}%;"></div>
                            </div>
                            
                            <div class="action-row">
                                <div class="anime-actions">
                                    <button class="plus-one-btn" data-index="${originalIndex}">+1</button>
                                    <button class="edit-btn" data-index="${originalIndex}">æ”¹</button>
                                    <button class="delete-btn" data-index="${originalIndex}">${entry.deleted ? 'å–æ¶ˆåˆ é™¤' : 'åˆ '}</button>
                                </div>
                            </div>
                        `;
                        animeRow.appendChild(item);
                    });

                    dayGroup.appendChild(animeRow);
                    overviewContainer.appendChild(dayGroup);
                }
            }
        }


        // --- 4. å¼¹çª—ä¸è¡¨å•å¤„ç† ---

        const animeModal = document.getElementById('animeModal');
        const showAddModalBtn = document.getElementById('showAddModalBtn');
        const animeForm = document.getElementById('animeForm');
        const modalTitle = document.getElementById('modalTitle');

        const animeTitleInput = document.getElementById('animeTitle');
        const totalEpisodesInput = document.getElementById('totalEpisodes');
        const initialUpdatedEpisodeInput = document.getElementById('initialUpdatedEpisode');
        const currentEpisodeInput = document.getElementById('currentEpisode');
        const updateDayOfWeekSelect = document.getElementById('updateDayOfWeek');

        let currentEditIndex = null;

        showAddModalBtn.addEventListener('click', () => {
            modalTitle.textContent = 'æ–°å¢ç•ªå‰§';
            animeForm.reset();
            currentEditIndex = null;

            totalEpisodesInput.value = 12;
            initialUpdatedEpisodeInput.value = 1;
            currentEpisodeInput.value = 1;

            const today = new Date();
            updateDayOfWeekSelect.value = today.getDay();

            animeModal.style.display = 'flex';
        });

        animeForm.addEventListener('submit', (e) => {
            e.preventDefault();

            const title = animeTitleInput.value.trim();
            const totalEpisodes = parseInt(totalEpisodesInput.value) || 0;
            const initialUpdatedEpisode = parseInt(initialUpdatedEpisodeInput.value) || 1;
            let currentEpisode = parseInt(currentEpisodeInput.value) || 1;
            const updateDayOfWeek = parseInt(updateDayOfWeekSelect.value);

            const tempEntry = {
                title, totalEpisodes,
                currentEpisode: currentEpisode,
                initialUpdatedEpisode,
                updateDayOfWeek,
                dateAdded: currentEditIndex !== null ? animeData[currentEditIndex].dateAdded : getTodayDateString()
            };

            const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(tempEntry);

            if (totalEpisodes > 0 && currentEpisode > totalEpisodes) {
                alert(`æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                return;
            }
            if (currentEpisode > calculatedUpdatedEp) {
                alert(`æ‚¨æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡å½“å‰å·²æ›´æ–°çš„é›†æ•° (${calculatedUpdatedEp})ï¼`);
                return;
            }
            if (totalEpisodes > 0 && initialUpdatedEpisode > totalEpisodes) {
                alert(`æºç«™å·²æ›´æ–°é›†æ•° (${initialUpdatedEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                return;
            }
            if (initialUpdatedEpisode < 1) {
                alert('æºç«™å·²æ›´æ–°é›†æ•°å¿…é¡»è‡³å°‘ä¸º 1ï¼');
                return;
            }


            const newEntry = {
                title,
                totalEpisodes,
                initialUpdatedEpisode,
                currentEpisode,
                updateDayOfWeek,
                dateAdded: getTodayDateString(),
                deleted: false
            };

            if (currentEditIndex !== null) {
                newEntry.dateAdded = animeData[currentEditIndex].dateAdded;
                newEntry.deleted = animeData[currentEditIndex].deleted;
                animeData[currentEditIndex] = newEntry;
                alert(`ç•ªå‰§ [${title}] å·²æ›´æ–°ï¼`);
            } else {
                animeData.push(newEntry);
                alert(`ç•ªå‰§ [${title}] å·²æˆåŠŸæ·»åŠ ï¼`);
            }

            saveToLocalStorage();
            renderOverview();
            animeModal.style.display = 'none';
            currentEditIndex = null;
        });


        // --- 5. GitHub é…ç½®å¼¹çª—å¤„ç† ---

        const githubConfigModal = document.getElementById('githubConfigModal');
        const configForm = document.getElementById('configForm');
        const githubTokenInput = document.getElementById('githubToken');
        const githubRepoPathInput = document.getElementById('githubRepoPath');

        function showConfigModal() {
            if (githubConfig.token) {
                githubTokenInput.value = githubConfig.token;
            } else {
                githubTokenInput.value = '';
            }
            githubConfigModal.style.display = 'flex';
        }

        configForm.addEventListener('submit', (e) => {
            e.preventDefault();

            const token = githubTokenInput.value.trim();
            if (!token) {
                alert('GitHub ä»¤ç‰Œä¸èƒ½ä¸ºç©ºï¼');
                return;
            }

            githubConfig.token = token;
            saveGithubConfig();
            githubConfigModal.style.display = 'none';

            syncData();
        });


        // --- 6. äº‹ä»¶ä»£ç† (åˆ é™¤é€»è¾‘ä¿®æ”¹) ---

        overviewContainer.addEventListener('click', (e) => {
            const target = e.target;
            const index = target.getAttribute('data-index');

            if (target.classList.contains('edit-btn')) {
                currentEditIndex = parseInt(index);
                const entry = animeData[currentEditIndex];

                if (entry.deleted) {
                    alert(`ç•ªå‰§ "${entry.title}" å·²æ ‡è®°ä¸ºå¾…åˆ é™¤çŠ¶æ€ï¼Œè¯·å…ˆç‚¹å‡»â€œå–æ¶ˆåˆ é™¤â€æŒ‰é’®å†è¿›è¡Œç¼–è¾‘ã€‚`);
                    return;
                }

                modalTitle.textContent = 'ç¼–è¾‘ç•ªå‰§ä¿¡æ¯';

                animeTitleInput.value = entry.title;
                totalEpisodesInput.value = entry.totalEpisodes;
                initialUpdatedEpisodeInput.value = entry.initialUpdatedEpisode;
                currentEpisodeInput.value = entry.currentEpisode;
                updateDayOfWeekSelect.value = entry.updateDayOfWeek;

                animeModal.style.display = 'flex';

            } else if (target.classList.contains('plus-one-btn')) {
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];

                if (entry.deleted) return;

                const calculatedUpdatedEp = calculateCurrentUpdatedEpisode(entry);

                if (entry.currentEpisode >= calculatedUpdatedEp) {
                    alert(`å½“å‰æ‚¨çœ‹çš„é›†æ•°å·²è¿½å¹³æœ€æ–°æ›´æ–°é›†æ•° (${calculatedUpdatedEp})ï¼Œè¯·ç­‰å¾…ä¸‹å‘¨æ›´æ–°ï¼`);
                    return;
                }
                if (entry.totalEpisodes > 0 && entry.currentEpisode >= entry.totalEpisodes) {
                    alert(`æ­å–œï¼ç•ªå‰§ [${entry.title}] å·²çœ‹å®Œï¼`);
                    return;
                }

                animeData[targetIndex].currentEpisode += 1;
                saveToLocalStorage();
                renderOverview();

            } else if (target.classList.contains('delete-btn')) {
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];

                if (entry.deleted) {
                    // å–æ¶ˆåˆ é™¤
                    entry.deleted = false;
                } else {
                    // æ ‡è®°ä¸ºå¾…åˆ é™¤
                    entry.deleted = true;
                }

                saveToLocalStorage();
                renderOverview();
            }
        });


        // --- 7. é€šç”¨æ¨¡æ€æ¡†å…³é—­é€»è¾‘ ---

        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.onclick = (e) => {
                const modal = e.target.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                    currentEditIndex = null;
                }
            };
        });


        // --- 8. åˆå§‹åŒ– ---
        document.addEventListener('DOMContentLoaded', () => {
            initData();
            renderOverview();

            updateTimeAndWeather();
            // æ¯ç§’æ›´æ–°æ—¶é—´
            setInterval(updateTimeAndWeather, 1000);

            document.getElementById('syncBtn').addEventListener('click', syncData);
        });
    </script>
</body>

</html>