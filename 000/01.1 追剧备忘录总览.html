<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿½ç•ªè¿›åº¦ç®¡ç† - è‡ªåŠ¨æ›´æ–°ç‰ˆ (æŒ‰æ›´æ–°æ—¥åˆ†ç»„)</title>

    <style>
        :root {
            --primary-color: #f67b8d;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #007bff;
            --bg-light: #f4f7f9;
            --card-bg: #ffffff;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --watching-color: #f67b8d;
            --update-color: #ffc107;
        }

        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif, 'Microsoft YaHei';
        }

        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-light);
            color: #333;
        }

        /* å¤´éƒ¨æ ·å¼è°ƒæ•´ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--watching-color) 0%, #ffc0cb 100%);
            padding: 20px 30px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            flex-wrap: wrap;
        }

        .header h1 {
            margin: 0;
            /* ç¡®ä¿æ ‡é¢˜ä¸ä¼šè¢«æŒ¤å‹ */
            flex-shrink: 0;
        }

        /* å¤´éƒ¨å³ä¾§å®¹å™¨ */
        .header-right {
            display: flex;
            align-items: center;
            /* MODIFIED: å‡å°æŒ‰é’®ä¹‹é—´çš„é—´è· */
            gap: 8px;
            flex-wrap: wrap;
            /* ç¡®ä¿å³ä¾§å†…å®¹åœ¨ç©ºé—´ä¸è¶³æ—¶å¯ä»¥æ¢è¡Œ */
            justify-content: flex-end;
            /* å…³é”®ï¼šç¡®ä¿å³ä¾§å†…å®¹å‘å³å¯¹é½ */
        }

        /* æ—¶é—´ä¿¡æ¯åŒºåŸŸ */
        .datetime-info {
            text-align: right;
            line-height: 1.3;
            /* MODIFIED: å‡å°å­—ä½“å¤§å°ï¼Œä½¿å…¶æ›´ç´§å‡‘ */
            font-size: 0.8em;
            opacity: 0.9;
            /* ç¡®ä¿æ—¶é—´ä¿¡æ¯åœ¨æŒ‰é’®ä¹‹å‰ */
            order: -1;
        }

        .datetime-info p {
            margin: 0;
            white-space: nowrap;
        }


        /* æŒ‰é’®æ ·å¼ */
        .action-btn,
        button:not(.anime-actions button) {
            /* MODIFIED: å‡å°æŒ‰é’®å†…è¾¹è· */
            padding: 7px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            /* MODIFIED: å‡å°å­—ä½“å¤§å° */
            font-size: 14px;
            transition: background-color 0.3s, transform 0.1s;
            flex-shrink: 0;
            /* é€‚å½“å‡å°æœ€å°å®½åº¦ï¼Œä½†ä¿è¯ä¸­æ–‡å¯è¯» */
            min-width: 70px;
        }

        .action-btn {
            background-color: white;
            color: var(--watching-color);
        }

        /* è°ƒæ•´åŒæ­¥/æ¨é€æŒ‰é’®çš„é¢œè‰² */
        #syncBtn,
        #pushBtn {
            background-color: #2196f3;
            color: white;
        }

        #syncBtn:hover,
        #pushBtn:hover {
            background-color: #1e88e5;
        }


        /* æ¯æ—¥åˆ†ç»„å®¹å™¨ */
        .day-group {
            margin-bottom: 25px;
            padding: 10px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .day-group h3 {
            color: var(--watching-color);
            border-bottom: 2px solid #ffedf0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        /* å¡ç‰‡æ’åˆ—è¡Œ - PC å·¦å¯¹é½ */
        .anime-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-start;
            justify-content: flex-start;
        }

        /* å•ä¸ªç•ªå‰§å¡ç‰‡ */
        .anime-item {
            width: 154px;
            max-width: 100%;
            padding: 10px;
            background-color: var(--bg-light);
            border: 1px solid #dee2e6;
            border-left: 5px solid var(--watching-color);
            border-radius: 6px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        /* å¾…åˆ é™¤çŠ¶æ€æ ·å¼ */
        .anime-item.deleted {
            opacity: 0.5;
            background-color: #ffeeee;
            border-left: 5px solid var(--danger-color);
            text-decoration: line-through;
        }

        /* ç¡®ä¿è¢«åˆ é™¤çš„é“¾æ¥ä¹Ÿè¢«åˆ’çº¿ */
        .anime-item.deleted .anime-content h4,
        .anime-item.deleted .anime-content h4 a {
            color: var(--danger-color) !important;
            text-decoration: line-through;
        }

        .anime-item.deleted .delete-btn {
            background-color: var(--secondary-color) !important;
        }


        .anime-content h4 {
            margin: 0 0 5px 0;
            color: #495057;
            font-size: 1em;
            overflow: hidden;
        }

        /* NEW: ç¡®ä¿ h4 å†…éƒ¨çš„é“¾æ¥ç»§æ‰¿æ ·å¼ */
        .anime-content h4 a {
            color: inherit;
            text-decoration: none;
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .anime-content h4 a:hover {
            text-decoration: underline;
        }


        /* è¿›åº¦ä¿¡æ¯å®¹å™¨ï¼šç´§å‡‘åŒ– */
        .progress-info {
            font-size: 0.8em;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }

        .progress-info p {
            margin: 0;
            line-height: 1.2;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 6px;
            margin-bottom: 5px;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--watching-color);
            transition: width 0.5s ease-in-out;
        }

        .updated-episode-display {
            color: var(--update-color);
            font-weight: bold;
        }

        .user-episode-display {
            color: var(--info-color);
            font-weight: bold;
        }

        /* åŠ¨ä½œè¡Œï¼šåªåŒ…å«æŒ‰é’® */
        .action-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dashed #eee;
        }

        /* æŒ‰é’®å®¹å™¨ï¼šå¹³å‡åˆ†é…ç©ºé—´ */
        .anime-actions {
            display: flex;
            width: 100%;
            gap: 5px;
        }

        .anime-actions button {
            flex-grow: 1;
            flex-basis: 0;
            padding: 5px 0;
            font-size: 0.8em;
            line-height: 1;
            margin: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .plus-one-btn {
            background-color: var(--success-color);
            color: white;
        }

        .edit-btn {
            background-color: var(--secondary-color);
            color: white;
        }

        .delete-btn {
            background-color: var(--danger-color);
            color: white;
        }


        /* å¼¹çª—éƒ¨åˆ† */
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 500px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-btn:hover {
            color: #000;
            cursor: pointer;
        }

        #animeForm label,
        #configForm label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }

        #animeForm input,
        #animeForm select,
        #configForm input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }

        /* NEW: é’ˆå¯¹æ—¥æœŸ+é›†æ•°æ ‡ç­¾ï¼Œå¢åŠ ä¸€ç‚¹æ ·å¼åŒºåˆ† */
        #updateDateDisplay {
            color: var(--info-color);
            font-weight: bold;
            margin-right: 3px;
        }

        #animeForm button[type="submit"],
        #configForm button[type="submit"] {
            width: 100%;
            background-color: var(--watching-color);
            color: white;
            padding: 12px;
        }


        /* === ç§»åŠ¨ç«¯åª’ä½“æŸ¥è¯¢ï¼šç¡®ä¿ç§»åŠ¨ç«¯ä»èƒ½æ­£ç¡®æ˜¾ç¤º === */
        @media (max-width: 500px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 15px;
                flex-direction: column;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
                text-align: center;
            }

            /* åœ¨ç§»åŠ¨ç«¯éšè—æ—¶é—´ä¿¡æ¯ï¼Œä¸ºæŒ‰é’®è…¾å‡ºç©ºé—´ */
            .datetime-info {
                display: none;
            }

            .header-right {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                width: 100%;
            }

            .action-btn,
            button:not(.anime-actions button) {
                width: 100%;
            }

            /* å¡ç‰‡å¸ƒå±€æ”¹ä¸ºå•åˆ—ï¼Œå¹¶æ‹‰ä¼¸ä»¥å……æ»¡å®½åº¦ */
            .anime-item {
                width: 100%;
                max-width: 100%;
            }

            .anime-row {
                gap: 10px;
                justify-content: stretch;
            }

            .day-group {
                padding: 5px;
            }
        }
    </style>
</head>

<body>
    <header class="header">
        <h1>ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†</h1>
        <div class="header-right">
            <div id="datetime-info" class="datetime-info">
                <p id="current-time">åŠ è½½ä¸­...</p>
            </div>
            <button id="syncBtn" class="action-btn">åŒå‘åŒæ­¥æ•°æ®</button>
            <button id="pushBtn" class="action-btn">æ¨é€æœ¬åœ°æ•°æ®</button>
            <button id="showAddModalBtn" class="action-btn">æ–°å¢ç•ªå‰§</button>
        </div>
    </header>

    <main id="overview-container" class="overview-container">
        <p class="loading-text">åŠ è½½ä¸­...</p>
    </main>

    <div id="animeModal" class="modal">
        <div class="modal-content">
            <span class="close-btn anime-close-btn">&times;</span>
            <h2 id="modalTitle">æ–°å¢ç•ªå‰§</h2>
            <form id="animeForm">
                <label for="animeTitle">ç•ªå‰§åç§°:</label>
                <input type="text" id="animeTitle" required>

                <label for="watchLink">è§‚çœ‹é“¾æ¥ (URL):</label>
                <input type="url" id="watchLink" placeholder="ä¾‹å¦‚: https://www.bilibili.com/...">

                <label for="totalEpisodes">æ€»é›†æ•° (0 è¡¨ç¤ºæœªçŸ¥):</label>
                <input type="number" id="totalEpisodes" min="0" value="12" required>

                <label for="manualUpdatedEpisode">
                    <span id="updateDateDisplay">æ—¥æœŸ</span>+æºç«™æœ€æ–°é›†æ•°:
                </label>
                <input type="number" id="manualUpdatedEpisode" min="1" value="1" required>

                <label for="currentEpisode">æ‚¨æ­£åœ¨çœ‹ç¬¬å‡ é›†:</label>
                <input type="number" id="currentEpisode" min="1" value="1" required>

                <label for="updateDayOfWeek">æ¯å‘¨æ›´æ–°æ—¥:</label>
                <select id="updateDayOfWeek" required>
                    <option value="0">å‘¨æ—¥</option>
                    <option value="1">å‘¨ä¸€</option>
                    <option value="2">å‘¨äºŒ</option>
                    <option value="3">å‘¨ä¸‰</option>
                    <option value="4">å‘¨å››</option>
                    <option value="5">å‘¨äº”</option>
                    <option value="6">å‘¨å…­</option>
                </select>

                <button type="submit" id="saveAnimeBtn">ä¿å­˜</button>
            </form>
        </div>
    </div>

    <div id="githubConfigModal" class="modal">
        <div class="modal-content">
            <span class="close-btn config-close-btn">&times;</span>
            <h2>GitHub åŒæ­¥é…ç½®</h2>
            <form id="configForm">
                <label for="githubToken">GitHub ä¸ªäººè®¿é—®ä»¤ç‰Œ (Token):</label>
                <input type="password" id="githubToken" placeholder="éœ€è¦ repo æƒé™çš„ä»¤ç‰Œ" required>

                <label for="githubRepoPath">åŒæ­¥åœ°å€ (ç”¨æˆ·å/ä»“åº“å/æ–‡ä»¶å):</label>
                <input type="text" id="githubRepoPath" readonly value="xgd1062/1062/çœ‹ç•ªè®°å½•.md">

                <button type="submit">ä¿å­˜å¹¶åŒæ­¥</button>
                <p style="font-size: 0.8em; margin-top: 15px; color: #666;">
                    * ä»¤ç‰Œä»…å­˜å‚¨åœ¨æ‚¨çš„æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚<br>
                    * è¯·ç¡®ä¿ä»¤ç‰Œæ‹¥æœ‰è®¿é—®è¯¥ä»“åº“çš„æƒé™ã€‚<br>
                    * **æ³¨æ„ï¼š** åœ¨æœ¬åœ° HTML ä¸­ç›´æ¥è°ƒç”¨ GitHub API å¯èƒ½<span style="font-weight: bold;">ä¼šé‡åˆ° CORS é™åˆ¶</span>ã€‚
                </p>
            </form>
        </div>
    </div>


    <script>
        // --- 1. æ•°æ®æ¨¡å‹ä¸å­˜å‚¨/æ ¸å¿ƒå·¥å…·å‡½æ•° ---
        const LS_KEY = 'animeTrackerWatchingOnlyV2';
        const CONFIG_KEY = 'githubSyncConfig';
        const DAY_NAMES = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];

        let animeData = [];
        let githubConfig = null;

        const DEFAULT_REPO_CONFIG = {
            owner: 'xgd1062',
            repo: '1062',
            path: 'çœ‹ç•ªè®°å½•.md',
            token: null,
            sha: null
        };

        /**
         * æ ¼å¼åŒ– Date å¯¹è±¡ä¸º 'YYYY-MM-DD' å­—ç¬¦ä¸²ã€‚
         * @param {Date} date
         * @returns {string}
         */
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        /**
         * è®¡ç®—æœ€è¿‘çš„æ›´æ–°æ—¥æœŸ (åŒ…æ‹¬ä»Šå¤©)ï¼Œè¿”å› Date å¯¹è±¡ (æ—¶é—´ä¸ºåˆå¤œ)ã€‚
         * @param {number} targetDayOfWeek 0 (Sun) to 6 (Sat)
         * @param {Date} dateToCheck åŸºå‡†æ—¥æœŸï¼Œé»˜è®¤ä¸ºå½“å‰æ—¥æœŸ
         * @returns {Date} è®¡ç®—å‡ºçš„æœ€è¿‘æ›´æ–°æ—¥æœŸ (åˆå¤œ)
         */
        function calculateLastUpdateDateObject(targetDayOfWeek, dateToCheck = new Date()) {
            const now = new Date(dateToCheck);
            now.setHours(0, 0, 0, 0); // è®¾ç½®ä¸ºåˆå¤œ
            const todayDay = now.getDay(); // 0 (Sun) - 6 (Sat)

            // è®¡ç®—éœ€è¦å›æº¯çš„å¤©æ•° (0 to 6)
            const daysToGoBack = (todayDay - targetDayOfWeek + 7) % 7;

            const updateDate = new Date(now);
            updateDate.setDate(now.getDate() - daysToGoBack);
            return updateDate;
        }

        /**
         * è®¡ç®—æœ€è¿‘çš„æ›´æ–°æ—¥æœŸ (åŒ…æ‹¬ä»Šå¤©)ï¼Œè¿”å› MM-DD å­—ç¬¦ä¸²ã€‚
         * ç”¨äºè¡¨å•æ ‡ç­¾æ˜¾ç¤ºã€‚
         */
        function calculateLastUpdateDate(targetDayOfWeek) {
            const dateObj = calculateLastUpdateDateObject(targetDayOfWeek);
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getDate()).padStart(2, '0');
            return `${month}-${day}`;
        }

        /**
         * è®¡ç®—ä»èµ·ç®—æ—¥æœŸåˆ°å½“å‰æ—¥æœŸä¹‹é—´ï¼Œå·²ç»è¿‡å»äº†å¤šå°‘ä¸ªæ›´æ–°æ—¥ï¼ˆå‘¨ï¼‰ã€‚
         * @param {Date} startDate èµ·ç®—æ—¥æœŸ (åˆå¤œ)
         * @param {Date} currentDate å½“å‰æ—¥æœŸ (åˆå¤œ)
         * @param {number} updateDayOfWeek æ¯å‘¨æ›´æ–°æ—¥
         * @returns {number} å·²ç»è¿‡å»çš„æ›´æ–°æ¬¡æ•°ï¼ˆå‘¨æ•°ï¼‰
         */
        function calculateWeeksElapsed(startDate, currentDate, updateDayOfWeek) {
            const startMidnight = new Date(startDate.getTime());
            startMidnight.setHours(0, 0, 0, 0);

            const currentMidnight = new Date(currentDate.getTime());
            currentMidnight.setHours(0, 0, 0, 0);

            if (currentMidnight.getTime() <= startMidnight.getTime()) {
                return 0; // å°šæœªåˆ°è¾¾èµ·ç®—æ—¥
            }

            // 1. æ‰¾åˆ°ç¬¬ä¸€ä¸ªä½äº startMidnight *ä¹‹å* çš„æ›´æ–°æ—¥
            let firstUpdateDate = new Date(startMidnight);
            const startDay = startMidnight.getDay();
            const dayDiff = (updateDayOfWeek - startDay + 7) % 7;

            firstUpdateDate.setDate(startMidnight.getDate() + dayDiff);

            // å¦‚æœè®¡ç®—å‡ºçš„ firstUpdateDate ç­‰äº startMidnightï¼Œè¯´æ˜èµ·ç®—æ—¥å½“å¤©å°±æ˜¯æ›´æ–°æ—¥
            // ä¸”èµ·ç®—é›†æ•°å·²ç»åŒ…å«äº†è¿™ä¸€é›†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä»ä¸‹ä¸€å‘¨å¼€å§‹è®¡ç®—ã€‚
            if (firstUpdateDate.getTime() === startMidnight.getTime()) {
                firstUpdateDate.setDate(firstUpdateDate.getDate() + 7);
            }

            let count = 0;
            let tempDate = firstUpdateDate;

            // 2. ç»Ÿè®¡ä» firstUpdateDate åˆ° currentMidnight ä¹‹é—´æœ‰å¤šå°‘å‘¨
            while (tempDate.getTime() <= currentMidnight.getTime()) {
                count++;
                tempDate.setDate(tempDate.getDate() + 7); // è·³è¿‡ä¸€å‘¨
            }

            return count;
        }


        /**
         * æ ¸å¿ƒï¼šæ ¹æ®èµ·ç®—ç‚¹è‡ªåŠ¨è®¡ç®—å½“å‰åº”è¯¥æ›´æ–°åˆ°çš„é›†æ•°ã€‚
         */
        function calculateUpdatedEpisode(entry, currentDate = new Date()) {
            // å¦‚æœæ•°æ®ä¸å®Œæ•´æˆ–å·²åˆ é™¤ï¼Œåˆ™ä½¿ç”¨å­˜å‚¨çš„ manualUpdatedEpisode (å·²æ˜¯è®¡ç®—åçš„æœ€æ–°å€¼)
            if (!entry.startCalculationDate || !entry.startCalculationEpisode || entry.deleted) {
                return entry.manualUpdatedEpisode || entry.initialUpdatedEpisode || 1; // å…¼å®¹æ—§å­—æ®µ
            }

            const startDate = new Date(entry.startCalculationDate);

            // 1. è®¡ç®—å‘¨æ•°
            const weeksElapsed = calculateWeeksElapsed(startDate, currentDate, entry.updateDayOfWeek);

            // 2. è®¡ç®—æ–°é›†æ•°
            let newEpisode = entry.startCalculationEpisode + weeksElapsed;

            // 3. é™åˆ¶é›†æ•°ä¸è¶…è¿‡æ€»é›†æ•°
            if (entry.totalEpisodes > 0) {
                newEpisode = Math.min(newEpisode, entry.totalEpisodes);
            }

            // ç¡®ä¿è‡³å°‘ä¸º 1
            return Math.max(1, newEpisode);
        }

        /**
         * NEW FUNCTION: æ›´æ–°èµ·ç®—æ—¥å’Œèµ·ç®—é›†æ•° (ä»…åœ¨æ‰‹åŠ¨æäº¤è¡¨å•æˆ–åŒæ­¥æ—¶è°ƒç”¨)ã€‚
         */
        function updateCalculationFields(entry, modifiedDateString, currentUpdatedEpisode) {
            const modifiedDate = new Date(modifiedDateString); // ä¿®æ”¹æ—¥ (åˆå¤œ)
            const updateDayOfWeek = entry.updateDayOfWeek;

            // è®¡ç®—æœ€è¿‘çš„æ›´æ–°æ—¥ï¼ˆåŒ…æ‹¬ä¿®æ”¹æ—¥ï¼‰
            const targetUpdateDateObj = calculateLastUpdateDateObject(updateDayOfWeek, modifiedDate);
            const targetUpdateDateString = formatDate(targetUpdateDateObj);

            // ä¿å­˜ä¿®æ”¹æ—¥
            entry.lastModifiedDate = modifiedDateString;

            // æ ¹æ®ç”¨æˆ·é€»è¾‘ï¼Œèµ·ç®—æ—¥å§‹ç»ˆä¸ºæœ€è¿‘çš„æ›´æ–°æ—¥
            // ä¸”èµ·ç®—é›†æ•°ä¸ºç”¨æˆ·åœ¨è¡¨å•ä¸­è¾“å…¥çš„æœ€æ–°é›†æ•°ã€‚
            entry.startCalculationDate = targetUpdateDateString;
            entry.startCalculationEpisode = currentUpdatedEpisode;

            // åŒæ—¶å°†ç”¨æˆ·è¾“å…¥çš„é›†æ•°ä½œä¸º manualUpdatedEpisode çš„ä¸´æ—¶åŸºå‡†ï¼Œ
            // æ¸²æŸ“æ—¶ä¼šæ ¹æ®å®ƒé‡æ–°è®¡ç®—æœ€æ–°çš„ manualUpdatedEpisodeã€‚
            entry.manualUpdatedEpisode = currentUpdatedEpisode;
        }

        function initData() {
            const storedData = localStorage.getItem(LS_KEY);
            if (storedData) {
                animeData = JSON.parse(storedData);
            }

            const todayDateString = formatDate(new Date());

            // å…¼å®¹æ—§æ•°æ®ï¼Œå¹¶åˆå§‹åŒ–æ–°çš„å­—æ®µ
            animeData = animeData.map(entry => {
                // ç»Ÿä¸€ä½¿ç”¨ manualUpdatedEpisode ä½œä¸ºåŸºå‡†é›†æ•°
                const baseUpdatedEp = entry.manualUpdatedEpisode || entry.initialUpdatedEpisode || 1;
                const updateDay = entry.updateDayOfWeek !== undefined ? parseInt(entry.updateDayOfWeek) : new Date().getDay();

                const baseEntry = {
                    ...entry,
                    deleted: entry.deleted === true,
                    watchLink: entry.watchLink || '',
                    // manualUpdatedEpisode å­˜å‚¨çš„å°†æ˜¯ä¸Šä¸€æ¬¡è®¡ç®—/æ‰‹åŠ¨è®¾å®šçš„åŸºå‡†å€¼
                    manualUpdatedEpisode: baseUpdatedEp,
                    updateDayOfWeek: updateDay,

                    // NEW FIELDS: å¦‚æœä¸å­˜åœ¨ï¼Œä½¿ç”¨ä»Šå¤©çš„æ—¥æœŸå’Œ manualUpdatedEpisode ä½œä¸ºåˆå§‹å€¼
                    lastModifiedDate: entry.lastModifiedDate || todayDateString,
                    startCalculationEpisode: entry.startCalculationEpisode || baseUpdatedEp,
                    startCalculationDate: entry.startCalculationDate || formatDate(calculateLastUpdateDateObject(updateDay)),

                    // æ¸…é™¤æ—§å­—æ®µ
                    dateAdded: undefined,
                    initialUpdatedEpisode: undefined
                };

                // åˆæ¬¡åŠ è½½æ—¶ï¼Œæ ¹æ®èµ·ç®—ç‚¹è®¡ç®—å‡ºå½“å‰çš„é›†æ•°ï¼Œæ›´æ–° manualUpdatedEpisode
                baseEntry.manualUpdatedEpisode = calculateUpdatedEpisode(baseEntry);

                // ç¡®ä¿ç”¨æˆ·è¿½ç•ªè¿›åº¦ä¸è¶…è¿‡æœ€æ–°é›†æ•°
                if (baseEntry.currentEpisode > baseEntry.manualUpdatedEpisode) {
                    baseEntry.currentEpisode = baseEntry.manualUpdatedEpisode;
                }

                return baseEntry;
            }).filter(entry => entry.title);

            const storedConfig = localStorage.getItem(CONFIG_KEY);
            if (storedConfig) {
                githubConfig = JSON.parse(storedConfig);
            } else {
                githubConfig = DEFAULT_REPO_CONFIG;
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem(LS_KEY, JSON.stringify(animeData));
        }

        function saveGithubConfig() {
            localStorage.setItem(CONFIG_KEY, JSON.stringify(githubConfig));
        }

        /**
         * æŒ‰æ›´æ–°æ—¥åˆ†ç»„ (ä¿æŒä¸å˜)
         */
        function groupAnimeByDay(data) {
            const grouped = {};
            const sortedData = [...data].sort((a, b) => {
                if (a.updateDayOfWeek !== b.updateDayOfWeek) {
                    return a.updateDayOfWeek - b.updateDayOfWeek;
                }
                return a.title.localeCompare(b.title, 'zh-CN');
            });

            sortedData.forEach((entry) => {
                const dayKey = entry.updateDayOfWeek.toString();
                if (!grouped[dayKey]) {
                    grouped[dayKey] = [];
                }
                grouped[dayKey].push({ entry, originalIndex: animeData.findIndex(item => item === entry) });
            });

            return grouped;
        }

        /**
         * æ›´æ–°æ—¶é—´æ˜¾ç¤º
         */
        function updateTimeAndWeather() {
            const now = new Date();
            const dayOfWeek = DAY_NAMES[now.getDay()];
            const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const dateString = `${now.getFullYear()}å¹´${now.getMonth() + 1}æœˆ${now.getDate()}æ—¥`;

            const timeElement = document.getElementById('current-time');
            if (timeElement) {
                // å§‹ç»ˆæ›´æ–°æ—¶é—´ï¼Œä¾èµ– CSS åª’ä½“æŸ¥è¯¢éšè—å…ƒç´ 
                timeElement.innerHTML = `${dateString} ${dayOfWeek} ${timeString}`;
            }
        }

        // --- 2. GitHub API åŠåŒæ­¥/æ¨é€é€»è¾‘ ---

        /**
         * ç”Ÿæˆ Markdown å†…å®¹ (è¿‡æ»¤æ‰å¾…åˆ é™¤è®°å½•)
         */
        function generateMarkdown(data) {
            const liveData = data.filter(entry => !entry.deleted);

            if (liveData.length === 0) {
                return `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º\n\n**æ— è¿½ç•ªè®°å½•**\n\n`;
            }

            const now = new Date();
            const timestamp = now.toLocaleString('zh-CN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });

            let markdown = `# ğŸ¿ è¿½ç•ªè¿›åº¦ç®¡ç†å¯¼å‡º (${timestamp})\n\n`;

            const groupedList = groupAnimeByDay(liveData);

            Object.keys(groupedList).sort((a, b) => parseInt(a) - parseInt(b)).forEach(dayKey => {
                const list = groupedList[dayKey].map(item => item.entry);
                const dayName = DAY_NAMES[parseInt(dayKey)];

                markdown += `## ${dayName}æ›´æ–° (${list.length}éƒ¨)\n\n`;

                markdown += '| åç§° | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | è§‚çœ‹é“¾æ¥ |\n';
                markdown += '| :--- | :--- | :--- | :--- | :--- |\n';

                list.forEach((entry) => {
                    // ä½¿ç”¨å·²è®¡ç®—å¥½çš„ manualUpdatedEpisode
                    const updatedEp = entry.manualUpdatedEpisode;
                    const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';

                    const watchUrl = entry.watchLink && entry.watchLink.startsWith('http') ? entry.watchLink : '#';
                    const linkText = entry.watchLink ? '[ç‚¹å‡»è§‚çœ‹]' : 'æ— é“¾æ¥';

                    markdown += `| [${entry.title}](${watchUrl}) | ${updatedEp} | ${entry.currentEpisode} | ${totalText} | ${linkText} |\n`;
                });
                markdown += '\n';
            });

            return markdown;
        }

        /**
         * è§£æ Markdown å†…å®¹å›æ•°æ®ç»“æ„ 
         */
        function parseMarkdownToData(markdownContent) {
            const lines = markdownContent.split('\n');
            const parsedData = [];
            let currentDay = 0;

            const dayNameToIndex = DAY_NAMES.reduce((acc, name, index) => {
                // ç§»é™¤â€œæ›´æ–°â€äºŒå­—è¿›è¡ŒåŒ¹é…
                acc[name + 'æ›´æ–°'] = index;
                return acc;
            }, {});

            lines.forEach(line => {
                const dayMatch = line.match(/^## (.+)\s\(.+éƒ¨\)/);
                if (dayMatch && dayMatch[1]) {
                    // å°è¯•åŒ¹é…å»é™¤ "æ›´æ–°" çš„æ—¥å
                    const fullDayName = dayMatch[1].replace('æ›´æ–°', '');
                    for (const name in dayNameToIndex) {
                        if (name.startsWith(fullDayName)) {
                            currentDay = dayNameToIndex[name];
                            break;
                        }
                    }
                }

                // åŒ¹é… 5 åˆ—æ•°æ®ï¼š| [æ ‡é¢˜](é“¾æ¥) | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | [ç‚¹å‡»è§‚çœ‹](é“¾æ¥) | æˆ– | [æ ‡é¢˜](é“¾æ¥) | æ›´æ–°è‡³ | è¿½ç•ªè¿›åº¦ | æ€»é›†æ•° | æ— é“¾æ¥ |
                const dataMatch = line.match(/^\| \[(.+?)\]\((.+?)\) \| (\d+) \| (\d+) \| (.+?) \| \[(.+?)\]\((.+?)\) \|$/) ||
                    line.match(/^\| \[(.+?)\]\((.+?)\) \| (\d+) \| (\d+) \| (.+?) \| (.+?) \|$/);

                if (dataMatch) {
                    const title = dataMatch[1].trim();
                    const watchLink = dataMatch[2].trim() === '#' ? '' : dataMatch[2].trim();
                    const updatedEpisode = parseInt(dataMatch[3]) || 1; // è¿œç¨‹æ–‡ä»¶ä¸­çš„æœ€æ–°é›†æ•° (ä½œä¸ºæ–°çš„åŸºå‡†)
                    const currentEpisode = parseInt(dataMatch[4]) || 1;
                    const totalEpisodesStr = dataMatch[5].trim();
                    const totalEpisodes = totalEpisodesStr === '??' ? 0 : parseInt(totalEpisodesStr) || 0;
                    const updateDayOfWeek = currentDay;

                    const today = new Date();
                    const todayDateString = formatDate(today);

                    const remoteEntry = {
                        title: title,
                        watchLink: watchLink,
                        totalEpisodes: totalEpisodes,
                        currentEpisode: currentEpisode,
                        manualUpdatedEpisode: updatedEpisode, // è¿œç¨‹æ–‡ä»¶ä¸­çš„æœ€æ–°é›†æ•°ä½œä¸ºåŸºå‡†
                        updateDayOfWeek: updateDayOfWeek,
                        deleted: false,
                        // åˆå§‹åŒ–è®¡ç®—å­—æ®µï¼Œä½¿ç”¨è¿œç¨‹æ•°æ®ä½œä¸ºæœ€æ–°åŸºå‡†
                        lastModifiedDate: todayDateString,
                        startCalculationEpisode: updatedEpisode,
                        startCalculationDate: todayDateString,
                    };

                    // è®¡ç®—å¹¶è®¾ç½®èµ·ç®—æ—¥ï¼ˆå³ï¼šä»¥åŒæ­¥æ—¥æœŸå’Œè¿œç¨‹é›†æ•°ä½œä¸ºæ–°çš„èµ·ç®—ç‚¹ï¼‰
                    updateCalculationFields(remoteEntry, todayDateString, updatedEpisode);

                    // é‡æ–°è®¡ç®— manualUpdatedEpisodeï¼Œå› ä¸ºè¿œç¨‹é›†æ•°å¯èƒ½æ˜¯æ˜¨å¤©è®¾ç½®çš„
                    remoteEntry.manualUpdatedEpisode = calculateUpdatedEpisode(remoteEntry, today);

                    // ç¡®ä¿è¿½ç•ªé›†æ•°ä¸è¶…é™
                    if (remoteEntry.currentEpisode > remoteEntry.manualUpdatedEpisode) {
                        remoteEntry.currentEpisode = remoteEntry.manualUpdatedEpisode;
                    }

                    parsedData.push(remoteEntry);
                }
            });

            return parsedData;
        }


        /**
         * åŒå‘åŒæ­¥æ—¶çš„åˆå¹¶å’Œåˆ é™¤å¤„ç†é€»è¾‘ (ä¿ç•™è¿œç¨‹ç‹¬æœ‰æ•°æ®)
         */
        function processRemoteAndDelete(remoteData, localData) {
            const localLiveRecords = localData.filter(item => !item.deleted);
            const localDeletedTitles = new Set(localData
                .filter(item => item.deleted)
                .map(item => item.title));

            // è¿œç¨‹æ•°æ®ä¸­ï¼Œæ’é™¤æ‰æœ¬åœ°å·²æ ‡è®°åˆ é™¤çš„è®°å½•
            const remoteLiveRecords = remoteData.filter(remoteEntry => {
                return !localDeletedTitles.has(remoteEntry.title);
            });

            const merged = [];
            const processedTitles = new Set();
            const today = new Date();
            const todayDateString = formatDate(today);

            // 1. å¤„ç†è¿œç¨‹è®°å½•ï¼šä¿ç•™è¿œç¨‹ç‹¬æœ‰çš„ï¼Œæ›´æ–°ä¸æœ¬åœ°åŒ¹é…çš„
            remoteLiveRecords.forEach(remoteEntry => {
                const localEntry = localLiveRecords.find(item => item.title === remoteEntry.title);
                const remoteBaseEpisode = remoteEntry.manualUpdatedEpisode;

                if (!localEntry) {
                    // è¿œç¨‹ç‹¬æœ‰è®°å½•ï¼šç›´æ¥æ·»åŠ 
                    merged.push(remoteEntry);
                    processedTitles.add(remoteEntry.title);
                } else {
                    // è®°å½•éƒ½å­˜åœ¨ï¼šä»¥è¿œç¨‹æ•°æ®ä¸ºå‡†æ›´æ–°
                    localEntry.currentEpisode = remoteEntry.currentEpisode;
                    localEntry.totalEpisodes = remoteEntry.totalEpisodes;
                    localEntry.watchLink = remoteEntry.watchLink;
                    localEntry.updateDayOfWeek = remoteEntry.updateDayOfWeek;

                    // æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœè¿œç¨‹è®°å½•çš„é›†æ•°ä¸æœ¬åœ°å½“å‰çš„è®¡ç®—é›†æ•°ä¸ä¸€è‡´ï¼Œåˆ™ä»¥è¿œç¨‹é›†æ•°ä½œä¸ºæ–°çš„èµ·ç®—åŸºå‡†
                    if (localEntry.manualUpdatedEpisode !== remoteBaseEpisode) {

                        // 1. è®¾ç½®æ–°çš„åŸºå‡†é›†æ•°
                        localEntry.manualUpdatedEpisode = remoteBaseEpisode;

                        // 2. æ ¹æ®è¿œç¨‹é›†æ•°å’ŒåŒæ­¥æ—¥æœŸï¼Œé‡æ–°è®¡ç®—èµ·ç®—åŸºå‡†ç‚¹
                        updateCalculationFields(localEntry, todayDateString, remoteBaseEpisode);
                    }

                    // 3. å†æ¬¡è¿›è¡Œè‡ªåŠ¨è®¡ç®—ï¼Œç¡®ä¿æœ¬åœ°æ˜¾ç¤ºæœ€æ–°é›†æ•°
                    const finalUpdatedEp = calculateUpdatedEpisode(localEntry, today);
                    localEntry.manualUpdatedEpisode = finalUpdatedEp;

                    // 4. é™åˆ¶ç”¨æˆ·è¿½ç•ªé›†æ•°
                    if (localEntry.currentEpisode > finalUpdatedEp) {
                        localEntry.currentEpisode = finalUpdatedEp;
                    }
                    merged.push(localEntry);
                    processedTitles.add(localEntry.title);
                }
            });

            // 2. æ·»åŠ æœ¬åœ°ç‹¬æœ‰è®°å½•
            localLiveRecords.forEach(localEntry => {
                if (!processedTitles.has(localEntry.title)) {
                    merged.push(localEntry);
                }
            });

            return merged;
        }

        async function fetchFileFromGithub(config) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.status === 404) {
                    return { content: null, sha: null };
                }

                if (!response.ok) {
                    const errorJson = await response.json().catch(() => ({ message: response.statusText }));
                    throw new Error(`GitHub Fetch Error: ${response.status} - ${errorJson.message || 'Unknown API Error'}`);
                }

                const contentData = await response.json();

                if (contentData.content && contentData.sha) {
                    const fileContent = decodeURIComponent(escape(atob(contentData.content)));
                    return { content: fileContent, sha: contentData.sha };
                }

                return { content: null, sha: null };

            } catch (error) {
                console.error("GitHub Fetch failed:", error);
                throw new Error(`è·å– GitHub æ–‡ä»¶å¤±è´¥: ${error.message || error}`);
            }
        }

        async function uploadFileToGithub(config, content, sha) {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;

            const base64Content = btoa(unescape(encodeURIComponent(content)));

            const payload = {
                message: sha ? `Sync: Update watch list via local app at ${new Date().toLocaleString('zh-CN')}` : `Sync: Initial upload of watch list via local app`,
                content: base64Content,
                sha: sha
            };

            try {
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${config.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`GitHub Upload Error: ${response.status} - ${errorJson.message || 'æœªçŸ¥é”™è¯¯'}`);
                }

                const result = await response.json();
                return result;

            } catch (error) {
                console.error("GitHub Upload failed:", error);
                throw new Error(`ä¸Šä¼  GitHub æ–‡ä»¶å¤±è´¥: ${error.message}`);
            }
        }

        /**
         * NEW FUNCTION: å°†æœ¬åœ°æ•°æ®å¼ºåˆ¶æ¨é€è¦†ç›–åˆ°äº‘ç«¯
         */
        async function pushLocalToCloud() {
            if (!githubConfig.token) {
                showConfigModal();
                return;
            }

            const pushBtn = document.getElementById('pushBtn');
            const originalText = pushBtn.textContent;
            pushBtn.textContent = 'æ¨é€ä¸­...';
            pushBtn.disabled = true;

            try {
                // 1. è·å–è¿œç¨‹æ–‡ä»¶çš„ SHA (ç”¨äºç‰ˆæœ¬æ§åˆ¶)
                const { sha } = await fetchFileFromGithub(githubConfig);

                // 2. ç¡®ä¿æ‰€æœ‰æœ¬åœ°è®°å½•çš„ manualUpdatedEpisode éƒ½æ˜¯æœ€æ–°çš„è®¡ç®—å€¼
                const today = new Date();
                animeData.forEach(entry => {
                    const calculatedEp = calculateUpdatedEpisode(entry, today);
                    entry.manualUpdatedEpisode = calculatedEp;
                    // ç¡®ä¿ç”¨æˆ·è§‚çœ‹è¿›åº¦ä¸è¶…è¿‡æœ€æ–°é›†æ•°
                    if (entry.currentEpisode > calculatedEp) {
                        entry.currentEpisode = calculatedEp;
                    }
                });

                // 3. è¿‡æ»¤å‡ºæœªåˆ é™¤çš„æœ¬åœ°æ•°æ® (æœ¬åœ°çŠ¶æ€å†³å®šäº†äº‘ç«¯æœ€ç»ˆçŠ¶æ€)
                const localLiveData = animeData.filter(entry => !entry.deleted);

                // 4. å°†æœ¬åœ°æ•°æ®è½¬æ¢æˆ Markdown
                const contentToUpload = generateMarkdown(localLiveData);

                // 5. ä¸Šä¼ è‡³ GitHub (ä½¿ç”¨è·å–åˆ°çš„ SHA)
                await uploadFileToGithub(githubConfig, contentToUpload, sha);

                alert('æ¨é€æˆåŠŸï¼šæœ¬åœ°æ•°æ®å·²è¦†ç›–äº‘ç«¯æ–‡ä»¶ï¼');

            } catch (error) {
                alert(`æ¨é€å¤±è´¥ï¼š${error.message}`);
                console.error(error);
            } finally {
                pushBtn.textContent = originalText;
                pushBtn.disabled = false;
            }
        }


        /**
         * åŸæœ‰çš„åŒå‘åŒæ­¥é€»è¾‘
         */
        async function syncData() {
            if (!githubConfig.token) {
                showConfigModal();
                return;
            }

            const syncBtn = document.getElementById('syncBtn');
            const originalText = syncBtn.textContent;
            syncBtn.textContent = 'åŒæ­¥ä¸­...';
            syncBtn.disabled = true;

            try {
                const { content: remoteContent, sha } = await fetchFileFromGithub(githubConfig);
                let contentToUpload = '';
                let newSha = sha;

                // 1. ç¡®ä¿æ‰€æœ‰æœ¬åœ°è®°å½•çš„ manualUpdatedEpisode éƒ½æ˜¯æœ€æ–°çš„è®¡ç®—å€¼ï¼Œä»¥ä¾›å¯¼å‡ºæˆ–åˆå¹¶
                const today = new Date();
                animeData.forEach(entry => {
                    const calculatedEp = calculateUpdatedEpisode(entry, today);
                    entry.manualUpdatedEpisode = calculatedEp;
                    if (entry.currentEpisode > calculatedEp) {
                        entry.currentEpisode = calculatedEp;
                    }
                });

                if (remoteContent && remoteContent.trim().length > 0) {
                    console.log('äº‘ç«¯æ–‡ä»¶å­˜åœ¨ï¼Œè¿›è¡Œåˆ é™¤å¤„ç†å’Œåˆå¹¶...');
                    const remoteData = parseMarkdownToData(remoteContent);

                    // åˆå¹¶æ•°æ®
                    const mergedData = processRemoteAndDelete(remoteData, animeData);

                    animeData = mergedData;
                    saveToLocalStorage();
                    renderOverview();

                    contentToUpload = generateMarkdown(mergedData);
                    alert('åŒå‘åŒæ­¥æˆåŠŸï¼šå·²å¤„ç†åˆ é™¤æ ‡è®°ï¼Œä¸‹è½½äº‘ç«¯è®°å½•å¹¶ä¸æœ¬åœ°è®°å½•åˆå¹¶ï¼Œåˆå¹¶åçš„æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°å¹¶é‡æ–°ä¸Šä¼ ï¼');
                } else {
                    console.log('äº‘ç«¯æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œç›´æ¥ä¸Šä¼ æœ¬åœ°æ•°æ®...');

                    const localLiveData = animeData.filter(entry => !entry.deleted);
                    animeData = localLiveData;
                    saveToLocalStorage();
                    renderOverview();

                    contentToUpload = generateMarkdown(localLiveData);
                    newSha = null;
                    alert('åŒå‘åŒæ­¥æˆåŠŸï¼šé¦–æ¬¡ä¸Šä¼ æœ¬åœ°æ•°æ®åˆ° GitHubï¼');
                }

                await uploadFileToGithub(githubConfig, contentToUpload, newSha);

            } catch (error) {
                alert(`åŒå‘åŒæ­¥å¤±è´¥ï¼š${error.message}`);
                console.error(error);
            } finally {
                syncBtn.textContent = originalText;
                syncBtn.disabled = false;
            }
        }


        // --- 3. æ¸²æŸ“è§†å›¾ ---
        const overviewContainer = document.getElementById('overview-container');

        /**
         * ç”ŸæˆæŒ‰ (ä»Šå¤©, æ˜¨å¤©, å‰å¤©, ..., æ˜å¤©, åå¤©) æ’åºçš„æ˜ŸæœŸç´¢å¼•åˆ—è¡¨ã€‚
         */
        function getDisplayDayOrder(todayIndex) {
            const order = [];
            // 1. Today
            order.push(todayIndex);

            // 2. Past days, moving backwards (i=1 to 6)
            for (let i = 1; i <= 6; i++) {
                // Calculate day index going backwards 
                const day = (todayIndex - i + 7) % 7;
                order.push(day);
            }
            return order;
        }

        function renderOverview() {
            overviewContainer.innerHTML = '';

            if (animeData.length === 0) {
                overviewContainer.innerHTML = '<p style="text-align:center; color:#999;">æš‚æ— è¿½ç•ªè®°å½•ï¼Œç‚¹å‡»â€œæ–°å¢ç•ªå‰§â€å¼€å§‹è¿½ç•ªå§ï¼</p>';
                return;
            }

            const today = new Date();
            const todayDayIndex = today.getDay(); // è·å–ä»Šå¤©çš„æ˜ŸæœŸå‡  (0-6)

            const groupedData = groupAnimeByDay(animeData);

            const displayDayOrder = getDisplayDayOrder(todayDayIndex);

            displayDayOrder.forEach((day, index) => {
                const list = groupedData[day];

                if (list && list.length > 0) {
                    let dayGroupName;

                    // æ ¹æ®åœ¨æ’åºæ•°ç»„ä¸­çš„ä½ç½®ç¡®å®šæ˜¾ç¤ºåç§°
                    if (index === 0) {
                        dayGroupName = DAY_NAMES[day] + ' (ä»Šå¤©)';
                    } else if (index === 1) {
                        dayGroupName = DAY_NAMES[day] + ' (æ˜¨å¤©)';
                    } else if (index === 6) {
                        // index 6 å¯¹åº” (today + 1) % 7ï¼Œä¹Ÿå°±æ˜¯æ˜å¤©
                        dayGroupName = DAY_NAMES[day] + ' (æ˜å¤©)';
                    } else {
                        // index 2, 3, 4, 5ï¼šæ˜¾ç¤ºæ­£å¸¸çš„å‘¨å‡ åç§°
                        dayGroupName = DAY_NAMES[day];
                    }


                    const dayGroup = document.createElement('div');
                    dayGroup.className = 'day-group';
                    dayGroup.innerHTML = `<h3>${dayGroupName}æ›´æ–° (${list.length}éƒ¨)</h3>`;

                    const animeRow = document.createElement('div');
                    animeRow.className = 'anime-row';

                    list.forEach(({ entry, originalIndex }) => {
                        // NEW: åœ¨æ¸²æŸ“å‰å®æ—¶è®¡ç®—æœ€æ–°é›†æ•°
                        const calculatedUpdatedEp = calculateUpdatedEpisode(entry, today);

                        // æ›´æ–°æ•°æ®æ¨¡å‹ä¸­çš„ manualUpdatedEpisode å’Œ currentEpisodeï¼ˆç”¨äºä¸‹æ¬¡åˆ·æ–°/åŒæ­¥ï¼‰
                        entry.manualUpdatedEpisode = calculatedUpdatedEp;
                        if (entry.currentEpisode > calculatedUpdatedEp) {
                            entry.currentEpisode = calculatedUpdatedEp;
                        }

                        const updatedEp = calculatedUpdatedEp;
                        const totalText = entry.totalEpisodes > 0 ? entry.totalEpisodes : '??';
                        const progressPercentage = entry.totalEpisodes > 0
                            ? Math.min(100, (entry.currentEpisode / entry.totalEpisodes) * 100).toFixed(0)
                            : 0;

                        const watchUrl = entry.watchLink && entry.watchLink.startsWith('http') ? entry.watchLink : '#';

                        const item = document.createElement('div');
                        item.className = 'anime-item' + (entry.deleted ? ' deleted' : '');

                        item.innerHTML = `
                            <div class="anime-content">
                                <h4 title="${entry.title}">
                                    <a href="${watchUrl}" target="_blank" style="color: inherit; text-decoration: none;">
                                        ${entry.title}
                                    </a>
                                </h4>
                            </div>

                            <div class="progress-info">
                                <p>æ€»é›†æ•°: ${totalText}</p>
                                <p>æ›´æ–°è‡³: <span class="updated-episode-display">${updatedEp}</span></p>
                                <p>æ‚¨åœ¨çœ‹: <span class="user-episode-display">${entry.currentEpisode}</span></p>
                            </div>

                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progressPercentage > 100 ? 100 : progressPercentage}%;"></div>
                            </div>
                            
                            <div class="action-row">
                                <div class="anime-actions">
                                    <button class="plus-one-btn" data-index="${originalIndex}">+1</button>
                                    <button class="edit-btn" data-index="${originalIndex}">æ”¹</button>
                                    <button class="delete-btn" data-index="${originalIndex}">${entry.deleted ? 'ä¸åˆ ' : 'åˆ '}</button>
                                </div>
                            </div>
                        `;
                        animeRow.appendChild(item);
                    });

                    dayGroup.appendChild(animeRow);
                    overviewContainer.appendChild(dayGroup);
                }
            });

            // æ¯æ¬¡æ¸²æŸ“åä¿å­˜æœ€æ–°çš„çŠ¶æ€
            saveToLocalStorage();
        }


        // --- 4. å¼¹çª—ä¸è¡¨å•å¤„ç† ---

        const animeModal = document.getElementById('animeModal');
        const showAddModalBtn = document.getElementById('showAddModalBtn');
        const animeForm = document.getElementById('animeForm');
        const modalTitle = document.getElementById('modalTitle');

        const animeTitleInput = document.getElementById('animeTitle');
        const watchLinkInput = document.getElementById('watchLink');
        const totalEpisodesInput = document.getElementById('totalEpisodes');
        const manualUpdatedEpisodeInput = document.getElementById('manualUpdatedEpisode');
        const currentEpisodeInput = document.getElementById('currentEpisode');
        const updateDayOfWeekSelect = document.getElementById('updateDayOfWeek');

        let currentEditIndex = null;

        showAddModalBtn.addEventListener('click', () => {
            modalTitle.textContent = 'æ–°å¢ç•ªå‰§';
            animeForm.reset();
            currentEditIndex = null;

            watchLinkInput.value = '';
            totalEpisodesInput.value = 12;
            manualUpdatedEpisodeInput.value = 1;
            currentEpisodeInput.value = 1;

            const defaultDay = new Date().getDay();
            updateDayOfWeekSelect.value = defaultDay;
            updateManualEpisodeLabel(defaultDay);

            animeModal.style.display = 'flex';
        });

        // ç›‘å¬æ›´æ–°æ—¥é€‰æ‹©æ¡†çš„å˜åŒ–ï¼Œå®æ—¶æ›´æ–°æ—¥æœŸæ ‡ç­¾
        updateDayOfWeekSelect.addEventListener('change', (e) => {
            updateManualEpisodeLabel(parseInt(e.target.value));
        });

        function updateManualEpisodeLabel(targetDayOfWeek) {
            const dateDisplay = document.getElementById('updateDateDisplay');
            if (dateDisplay) {
                const dateString = calculateLastUpdateDate(targetDayOfWeek);
                dateDisplay.textContent = dateString;
            }
        }

        animeForm.addEventListener('submit', (e) => {
            e.preventDefault();

            const title = animeTitleInput.value.trim();
            const watchLink = watchLinkInput.value.trim();
            const totalEpisodes = parseInt(totalEpisodesInput.value) || 0;
            // è·å–ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥çš„é›†æ•°ï¼Œä½œä¸ºæ–°çš„èµ·ç®—é›†æ•°åŸºå‡†
            const manualUpdatedEpisode = parseInt(manualUpdatedEpisodeInput.value) || 1;
            let currentEpisode = parseInt(currentEpisodeInput.value) || 1;
            const updateDayOfWeek = parseInt(updateDayOfWeekSelect.value);

            const today = new Date();
            const todayDateString = formatDate(today);

            if (totalEpisodes > 0 && currentEpisode > totalEpisodes) {
                alert(`æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                return;
            }
            // æ ¡éªŒä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åŸºå‡†é›†æ•°
            if (currentEpisode > manualUpdatedEpisode) {
                alert(`æ‚¨æ­£åœ¨çœ‹çš„é›†æ•° (${currentEpisode}) ä¸èƒ½è¶…è¿‡å½“å‰å·²è®¾ç½®çš„é›†æ•° (${manualUpdatedEpisode})ï¼`);
                return;
            }
            if (totalEpisodes > 0 && manualUpdatedEpisode > totalEpisodes) {
                alert(`æºç«™æœ€æ–°é›†æ•° (${manualUpdatedEpisode}) ä¸èƒ½è¶…è¿‡æ€»é›†æ•° (${totalEpisodes})ï¼`);
                return;
            }
            if (manualUpdatedEpisode < 1) {
                alert('æºç«™æœ€æ–°é›†æ•°å¿…é¡»è‡³å°‘ä¸º 1ï¼');
                return;
            }

            // æ„å»ºæ–°çš„ Entry å¯¹è±¡
            const newEntry = {
                title,
                watchLink,
                totalEpisodes,
                currentEpisode,
                updateDayOfWeek,
                deleted: false,

                // åˆå§‹åŒ–/æ›´æ–°è®¡ç®—å­—æ®µï¼Œå¹¶è®¾ç½® manualUpdatedEpisode çš„åŸºå‡†å€¼
                lastModifiedDate: todayDateString,
                startCalculationEpisode: manualUpdatedEpisode,
                startCalculationDate: todayDateString,
                manualUpdatedEpisode: manualUpdatedEpisode, // æš‚å­˜ç”¨æˆ·è¾“å…¥çš„åŸºå‡†å€¼
            };

            // æ ¸å¿ƒé€»è¾‘ï¼šè®¡ç®—å¹¶è®¾ç½®èµ·ç®—æ—¥å’Œèµ·ç®—é›†æ•°
            updateCalculationFields(newEntry, todayDateString, manualUpdatedEpisode);

            // é‡æ–°è®¡ç®—å¹¶æ›´æ–° manualUpdatedEpisode çš„æœ€æ–°å€¼
            newEntry.manualUpdatedEpisode = calculateUpdatedEpisode(newEntry, today);

            // å†æ¬¡é™åˆ¶ currentEpisode
            if (newEntry.currentEpisode > newEntry.manualUpdatedEpisode) {
                newEntry.currentEpisode = newEntry.manualUpdatedEpisode;
            }

            if (currentEditIndex !== null) {
                // å¦‚æœæ˜¯ä¿®æ”¹æ“ä½œ
                newEntry.deleted = animeData[currentEditIndex].deleted;
                // å¦‚æœç”¨æˆ·æ²¡æœ‰åœ¨è¡¨å•ä¸­ä¿®æ”¹ currentEpisodeï¼Œåˆ™ä¿æŒåŸæœ‰å€¼
                if (currentEpisodeInput.value === animeData[currentEditIndex].currentEpisode.toString()) {
                    newEntry.currentEpisode = animeData[currentEditIndex].currentEpisode;
                }

                // å†æ¬¡é™åˆ¶ currentEpisodeï¼ˆä»¥é˜²ç”¨æˆ·åªæ”¹äº†æ›´æ–°é›†æ•°ï¼Œä½†å¿˜è®°ä¿®æ”¹è¿½ç•ªé›†æ•°ï¼‰
                if (newEntry.currentEpisode > newEntry.manualUpdatedEpisode) {
                    newEntry.currentEpisode = newEntry.manualUpdatedEpisode;
                }

                animeData[currentEditIndex] = newEntry;
                alert(`ç•ªå‰§ [${title}] å·²æ›´æ–°ï¼`);
            } else {
                // æ–°å¢æ“ä½œ
                animeData.push(newEntry);
                alert(`ç•ªå‰§ [${title}] å·²æˆåŠŸæ·»åŠ ï¼`);
            }

            saveToLocalStorage();
            renderOverview();
            animeModal.style.display = 'none';
            currentEditIndex = null;
        });


        // --- 5. GitHub é…ç½®å¼¹çª—å¤„ç† ---

        const githubConfigModal = document.getElementById('githubConfigModal');
        const configForm = document.getElementById('configForm');
        const githubTokenInput = document.getElementById('githubToken');
        const githubRepoPathInput = document.getElementById('githubRepoPath');

        function showConfigModal() {
            if (githubConfig.token) {
                githubTokenInput.value = githubConfig.token;
            } else {
                githubTokenInput.value = '';
            }
            githubConfigModal.style.display = 'flex';
        }

        document.getElementById('syncBtn').addEventListener('click', syncData);
        document.getElementById('pushBtn').addEventListener('click', pushLocalToCloud);

        configForm.addEventListener('submit', (e) => {
            e.preventDefault();

            const token = githubTokenInput.value.trim();
            if (!token) {
                alert('GitHub ä»¤ç‰Œä¸èƒ½ä¸ºç©ºï¼');
                return;
            }

            githubConfig.token = token;
            saveGithubConfig();
            githubConfigModal.style.display = 'none';

            // é»˜è®¤ç»§ç»­æ‰§è¡ŒåŒå‘åŒæ­¥
            syncData();
        });


        // --- 6. äº‹ä»¶ä»£ç† (åˆ é™¤é€»è¾‘ä¿®æ”¹) ---

        overviewContainer.addEventListener('click', (e) => {
            const target = e.target;
            const index = target.getAttribute('data-index');

            if (target.classList.contains('edit-btn')) {
                currentEditIndex = parseInt(index);
                const entry = animeData[currentEditIndex];

                if (entry.deleted) {
                    alert(`ç•ªå‰§ "${entry.title}" å·²æ ‡è®°ä¸ºå¾…åˆ é™¤çŠ¶æ€ï¼Œè¯·å…ˆç‚¹å‡»â€œå–æ¶ˆåˆ é™¤â€æŒ‰é’®å†è¿›è¡Œç¼–è¾‘ã€‚`);
                    return;
                }

                modalTitle.textContent = 'ç¼–è¾‘ç•ªå‰§ä¿¡æ¯';

                // æ¸²æŸ“æ—¶ manualUpdatedEpisode å·²ç»æ˜¯æœ€æ–°è®¡ç®—å€¼ï¼Œå°†å…¶æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸­
                const latestEp = entry.manualUpdatedEpisode;

                animeTitleInput.value = entry.title;
                watchLinkInput.value = entry.watchLink || '';
                totalEpisodesInput.value = entry.totalEpisodes;
                manualUpdatedEpisodeInput.value = latestEp;
                currentEpisodeInput.value = entry.currentEpisode;
                updateDayOfWeekSelect.value = entry.updateDayOfWeek;

                // MODIFIED: æ›´æ–°æ—¥æœŸæ ‡ç­¾
                updateManualEpisodeLabel(entry.updateDayOfWeek);

                animeModal.style.display = 'flex';

            } else if (target.classList.contains('plus-one-btn')) {
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];

                if (entry.deleted) return;

                const updatedEp = entry.manualUpdatedEpisode; // ä½¿ç”¨å½“å‰è®¡ç®—çš„æœ€æ–°å€¼

                if (entry.currentEpisode >= updatedEp) {
                    alert(`å½“å‰æ‚¨çœ‹çš„é›†æ•°å·²è¿½å¹³æœ€æ–°æ›´æ–°é›†æ•° (${updatedEp})ï¼Œè¯·æ‰‹åŠ¨ä¿®æ”¹â€œæ—¥æœŸ+æºç«™æœ€æ–°é›†æ•°â€åå† +1ï¼`);
                    return;
                }
                if (entry.totalEpisodes > 0 && entry.currentEpisode >= entry.totalEpisodes) {
                    alert(`æ­å–œï¼ç•ªå‰§ [${entry.title}] å·²çœ‹å®Œï¼`);
                    return;
                }

                animeData[targetIndex].currentEpisode += 1;
                saveToLocalStorage();
                renderOverview();

            } else if (target.classList.contains('delete-btn')) {
                const targetIndex = parseInt(index);
                const entry = animeData[targetIndex];

                if (entry.deleted) {
                    // å–æ¶ˆåˆ é™¤
                    entry.deleted = false;
                } else {
                    // æ ‡è®°ä¸ºå¾…åˆ é™¤
                    entry.deleted = true;
                }

                saveToLocalStorage();
                renderOverview();
            }
        });


        // --- 7. é€šç”¨æ¨¡æ€æ¡†å…³é—­é€»è¾‘ ---

        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.onclick = (e) => {
                const modal = e.target.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                    currentEditIndex = null;
                }
            };
        });


        // --- 8. åˆå§‹åŒ– ---
        document.addEventListener('DOMContentLoaded', () => {
            initData();
            renderOverview();

            updateTimeAndWeather();
            // æ¯ç§’æ›´æ–°æ—¶é—´
            setInterval(updateTimeAndWeather, 1000);

            // åˆå§‹åŒ–è¡¨å•æ—¥æœŸæ˜¾ç¤º (é’ˆå¯¹æ–°å¢/åˆæ¬¡æ‰“å¼€)
            updateManualEpisodeLabel(new Date().getDay());
        });
    </script>
</body>

</html>